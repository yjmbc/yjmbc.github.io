<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Learns on YJMBC Blog</title>
    <link>https://yjmbc.github.io/learn/</link>
    <description>Recent content in Learns on YJMBC Blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 21 Jun 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://yjmbc.github.io/learn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Vue2 -&gt; Vue3</title>
      <link>https://yjmbc.github.io/learn/vue-diff/</link>
      <pubDate>Fri, 21 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://yjmbc.github.io/learn/vue-diff/</guid>
      <description>api 风格 选项式api 组合式api 组合式api 生命周期钩子对比 vue2 vue3 beforeCreate / created setup beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeDestroy onBeforeUnmount destroyed onUnmounted setup(props, context) { // Attribute (非响应式对象，等同于 $attrs) context.attrs // 插槽 (非响应式对象，等同于 $slots) context.slots // 触发事件 (方法，等同于 $emit) context.emit // 暴露公共 property (函数) context.expose return {} } 响应式 对象和数组的动态变化 const data = { name: &amp;#39;aa&amp;#39;, id: 001, information: { tel: &amp;#39;111xxxxx123&amp;#39;, email: &amp;#39;12xxxxx@xx.com&amp;#39; } } data.id = { number: 001 }; ✅ data.</description>
    </item>
    <item>
      <title>Markdown 语法学习</title>
      <link>https://yjmbc.github.io/learn/markdown/</link>
      <pubDate>Thu, 20 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://yjmbc.github.io/learn/markdown/</guid>
      <description>标题语法 # h1 ## h2 以此类推 到6 记得有空格 内容 ====== 表示h1 内容 ------ 表示h2 = / - 数量任意 ### 内容 {#id的名字} =》 &amp;lt;h3 id=&amp;#34;id的名字&amp;#34;&amp;gt;内容&amp;lt;/h3&amp;gt; 好像有的不支持 段落 空行空出来就分段了&#xA;换行 结尾空格&#xA;字体样式 **加粗内容** __加粗内容__ *斜体* _斜体_ ***粗体且斜体*** ___粗体且斜体___ 引用 &amp;gt;引用内容 &amp;gt; &amp;gt;放在一段里面的引用内容 &amp;gt; &amp;gt;&amp;gt;引用里面引用 列表 有序列表 1. 内容 2. 内容 数字+. 前面数字是啥无所谓，但一定要是1开始 无序列表 - 列表 * 列表 + 列表 + 缩进列表 三个符号都可以 代码 代码&#xA;分隔线 内容 ************** -------------- ______________ * - _ 都可以作为分隔符 a标签语法 [a标签显示内容](链接地址 &amp;quot;title&amp;quot;)e.</description>
    </item>
    <item>
      <title>Electron 主进程 渲染进程</title>
      <link>https://yjmbc.github.io/learn/electron-communication/</link>
      <pubDate>Wed, 19 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://yjmbc.github.io/learn/electron-communication/</guid>
      <description>electron 实际上是 chromium浏览器环境 + node环境 + 原生api的环境&#xA;但三种环境在electron里不是哪里都可以用的，他把js分成了主进程环境和渲染进程环境 每个 Electron 应用都有一个单一的主进程，作为应用程序的入口点。 主进程在 Node.js 环境中运行，这意味着它具有 require 模块和使用所有 Node.js API 的能力,也拥有访问原生api的能力&#xA;等到渲染进程就不再拥有这个能力了，所以有preload,他在页面加载之前执行，在这里仍然拥有访问node的能力。 语境隔离（Context Isolation）意味着预加载脚本与渲染器的主要运行环境是隔离开来的，以避免泄漏任何具特权的 API 到您的网页内容代码中。就是说preload中挂在window上的内容在渲染进程里访问不到&#xA;那如果要在渲染的页面里面拿到preload里定义的方法，这个时候就可以使用contextBridge 进程间通信 https://www.electronjs.org/zh/docs/latest/tutorial/ipc&#xA;渲染进程发，主进程听（单向） preload 里 ipcRenderer.send html页面里面，调用window上的api里注册的方法，就是preload里面注册的方法名字 main.js 里 ipcMain.on监听&#xA;渲染进程发，主进程听完返回，相互通信（双向） preload里 ipcRenderer.invoke() html页面里面，调用上面的方法，同样在window上 main.js里面ipcMain.handle()&#xA;主进程发，渲染进程听 main.js里面 mainWindow.webContents.send mainWindow就是渲染进程实例 然后再preload里面进行 ipcRenderer.on听 最后再页面上 调用preload里面定义的方法，做逻辑处理&#xA;如果这里想要通信回去，就在页面上调用的方法里面，再调用一个方法发送给主进程&#xA;两个渲染器进程 之能拿主进程做中转</description>
    </item>
  </channel>
</rss>
