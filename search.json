[{"content":"标题语法 # h1 ## h2 以此类推 到6 记得有空格 内容 ====== 表示h1 内容 ------ 表示h2 = / - 数量任意 ### 内容 {#id的名字} =》 \u003ch3 id=\"id的名字\"\u003e内容\u003c/h3\u003e 好像有的不支持 段落 空行空出来就分段了\n换行 结尾空格\n字体样式 **加粗内容** __加粗内容__ *斜体* _斜体_ ***粗体且斜体*** ___粗体且斜体___ 引用 \u003e引用内容 \u003e \u003e放在一段里面的引用内容 \u003e \u003e\u003e引用里面引用 列表 有序列表 1. 内容 2. 内容 数字+. 前面数字是啥无所谓，但一定要是1开始 无序列表 - 列表 * 列表 + 列表 + 缩进列表 三个符号都可以 代码 代码\n分隔线 内容 ************** -------------- ______________ * - _ 都可以作为分隔符 a标签语法 [a标签显示内容](链接地址 \"title\")e.g. [百度](https://www.baidu.com \"百度\")\n图片 ![图片alt](图片链接 \"图片title\")\n转义字符\\ 支持html标签插入 表格 | Title1\t| Title2 | | --------- |\t-------- | | content1 | content2 | # 不一定要对齐 | Syntax | Description | Test Text | | :--- | :----: | ---: | | 左对齐 | 剧中 | 右对齐 | 注脚 [^数字或者单词] 不能包含空格和制表符 Here's a simple footnote,[^1] and here's a longer one.[^bignote] [^1]: 注脚1 [^bignote]: 注脚2 删除线 删除线\n任务列表 - [x] x代表这一项完成了 - [ ] 空白代表还没有 自动网址链接 链接如果希望他仅仅做展示，不希望点击后跳走，可以使用反引号http://xxxxx.com\n","description":"markdown 语法学习","tags":["学习杂记","2024"],"title":"Markdown 语法学习","uri":"/learn/markdown/"},{"content":"electron 实际上是 chromium浏览器环境 + node环境 + 原生api的环境\n但三种环境在electron里不是哪里都可以用的，他把js分成了主进程环境和渲染进程环境 每个 Electron 应用都有一个单一的主进程，作为应用程序的入口点。 主进程在 Node.js 环境中运行，这意味着它具有 require 模块和使用所有 Node.js API 的能力,也拥有访问原生api的能力\n等到渲染进程就不再拥有这个能力了，所以有preload,他在页面加载之前执行，在这里仍然拥有访问node的能力。 语境隔离（Context Isolation）意味着预加载脚本与渲染器的主要运行环境是隔离开来的，以避免泄漏任何具特权的 API 到您的网页内容代码中。就是说preload中挂在window上的内容在渲染进程里访问不到\n那如果要在渲染的页面里面拿到preload里定义的方法，这个时候就可以使用contextBridge 进程间通信 https://www.electronjs.org/zh/docs/latest/tutorial/ipc\n渲染进程发，主进程听（单向） preload 里 ipcRenderer.send html页面里面，调用window上的api里注册的方法，就是preload里面注册的方法名字 main.js 里 ipcMain.on监听\n渲染进程发，主进程听完返回，相互通信（双向） preload里 ipcRenderer.invoke() html页面里面，调用上面的方法，同样在window上 main.js里面ipcMain.handle()\n主进程发，渲染进程听 main.js里面 mainWindow.webContents.send mainWindow就是渲染进程实例 然后再preload里面进行 ipcRenderer.on听 最后再页面上 调用preload里面定义的方法，做逻辑处理\n如果这里想要通信回去，就在页面上调用的方法里面，再调用一个方法发送给主进程\n两个渲染器进程 之能拿主进程做中转\n","description":"Electron 主进程 渲染进程","tags":["electron","2024"],"title":"Electron 主进程 渲染进程","uri":"/learn/electron-communication/"},{"content":"前提 毕业以后我的工资全部都存在工商银行的卡里，一般默认存进去的钱自动存活期，但是今年五月发现并没有，所以萌生了理财的想法。\n余额宝里目前有一些钱，然后就是把上面工商的钱存了定期，但是利率1.7有点低。理财产品看不懂，想先找一本书来看看，听说小狗钱钱可以入门。\n读书笔记 72定律\n72 除以投资的年收益率的百分比，得出的数字就是这笔钱翻一倍所要的年数\n72公式也可以用来帮助我们计算通货膨胀。它可以告诉我们，在一定通货膨胀率下，我们的钱在多长时间后会贬值一半。\n比如按72除以3%的通货膨胀率计算，得到24，就是说24年以后，你的钱只值现在的一半。\n记录 书里还提到一个观点时金钱不能使人变得幸福，幸福的人得到金钱会变得更加幸福，但是悲惨的人不会因为得到金钱而变得幸福。感觉很有道理，幸福的能力是自己给的，金钱固然能提升人的生活质量但是幸福的能力还是要靠自己来创造。\n书中对基金的概念也有了一个比较清晰易懂的介绍，基金是经理人受限要求购买至少二十种股票，然后把风险平坦，保证最终受益。书中的观点是行业都会迎来低谷期，但只有低谷期不卖出，就不会亏损，然后总会迎来行业回暖。\n书中主角对自己的财产进行了比例划分来进行管理，她将50%作为会下单的鹅，可持续发展，钱生钱。40%作为梦想基金来实现目标，所以在最开始就设立了要实现的目标。10%作为消费。\n我以前总是会把前面这90%搞混在一起，看起来好像没什么区别，但是风险小了，收益也小了。很多时候目标是攒钱，但是10%的界限又会越过，所以一个清晰的比例也有助于我对自己的钱有一个比较清晰的掌控。 我和主角的比例可能不太一样，我目前对理财有了一个大概的基础认知，算是入门了，我还要再学习一下相关知识。\n","description":"小狗钱钱-理财入门第一本","tags":["book","2024"],"title":"小狗钱钱-入门第一本","uri":"/readothers/finance-first/"},{"content":"安装 https://gohugo.io/installation/windows/直接用 scoop 安装最方便 go 安装msi文件运行就可以了\n新建 hugo new site [网站名字]\n挑选一个主题 https://themes.gohugo.io/\ngit submodule add [主题的github地址]\n在 hugo.toml 里面定义主题 theme = '主题名字'\nhugo server 启动\nhugo server -D 预览\n新建文章 hugo new content posts/my-first-post.md\nhugo 打包文件 会放到 public 目录下面\ngithub page 创建一个仓库 命名 username.github.io 然后把远程仓库拉到本地 git clone 远程仓库 把上面 public 目录下的所有文件复制过来 提交 推送远程仓库 访问 username.github.io hugo.toml 文件 # 设置默认语言为简体中文 defaultContentLanguage = 'zh-cn' # 要注意配置文件的 url 要更改成github page的路径！！！ baseURL = 'https://yjmbc.github.io/' [Params] # 指示网站是否为自托管 selfHosted = true # 设置日期格式为\"2006-01-02\"，即年-月-日 dateFormat = \"2006-01-02\" # 是否显示文章的预估阅读时间 readingTime = true # 是否在文章末尾显示字数统计 wordCount = true # 是否使用highlight.js进行代码高亮 useHLJS = true # 是否在文章底部显示相关文章推荐 showRelatedPosts = true # 是否显示文章的最后修改时间 Lastmod = true # 分页设置，每页显示的文章数量 pagination = \"10\" # 是否在文章页面隐藏作者信息 hideAuthor = true # 网站描述，可自定义内容 description=\"Your can add your website description here.\" # 是否启用基于Lunr的客户端搜索功能 lunrSearch = true # 预览卡片中图片的位置，此处设为显示在底部 previewCardImagePlacement = \"bottom\" # 用来设置右上角的导航栏内容, url 对应 content 目录下的路径 [[menu.main]] name = \"首页\" url = \"/\" weight = 1 # weight 用来定义导航栏的展示顺序，数值越小越靠前 [[menu.main]] name = \"学习记录\" url = \"/learn/\" weight = 2 文章开头定义 使用主题： lightbi-hugo\n--- title: hugo 实践记录 date: 2024-06-14 tags: [\"hugo\"] image : \"/img/work/bird.jpg\" Description : \"hugo 构建个人博客页并部署到 github page 全过程简便记录...\" --- tags 标签可以定义文章属于哪个标签，然后在 tags页面下按照标签展示img 是缩略卡片展示的图片内容以及内容页的展示图片，路径为themes/主题名字/assets/img下的路径\n文章导入过程 由于习惯用语雀进行记录，所以文章可以使用语雀进行编写，导出成markdown文件再放进来 提交 blog 项目一个仓库A，打包之后放到 github page 上的文件一个仓库B\nA 本地修改完成之后，hugo打包生成静态资源 # Hugo生成的静态文件 public/ # Hugo缓存目录 resources/ cache/ $hugocfg/workDir/ # 编译相关的临时文件 dist/ out/ build/ # Go模块的缓存 go.sum pkg/mod/ #编辑器和IDE相关的忽略规则 .idea/ .vscode/ *.sublime-workspace *.swp *.swo # 个人身份认证或密钥文件（确保不在版本控制中泄露敏感信息） id_rsa id_rsa.pub known_hosts # 其他可能不需要的文件类型 .DS_Store Thumbs.db *.log *.bak *.tmp 提交A到代码仓库 删除 github page 关联仓库B下所有代码 B重新关联 远程仓库 复制A public 文件夹下的内容到该项目B下 提交B到代码仓库 hugo time=$(date \"+%Y-%m-%d %H:%M:%S\") echo $time git add . git commit -m \"feat: 自动提交hugo代码 $time\" git push cd ../yjmbc.github.io/ rm -rf ./* git init git remote add origin https://github.com/yjmbc/yjmbc.github.io.git cd ../my-blog/ cp -r ./public/* ../yjmbc.github.io/ cd ../yjmbc.github.io/ git checkout main git add . git commit -m \"feat: 自动提交hugo public代码 $time\" git push 运行 build.sh 文件\n","description":"hugo 构建个人博客页并部署到 github page 全过程简便记录...","tags":["hugo","2024"],"title":"hugo 实践记录","uri":"/work/hugo-start/"}]
