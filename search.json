[{"content":"api 风格 选项式api 组合式api 组合式api 生命周期钩子对比 vue2 vue3 beforeCreate / created setup beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeDestroy onBeforeUnmount destroyed onUnmounted setup(props, context) { // Attribute (非响应式对象，等同于 $attrs) context.attrs // 插槽 (非响应式对象，等同于 $slots) context.slots // 触发事件 (方法，等同于 $emit) context.emit // 暴露公共 property (函数) context.expose return {} } 响应式 对象和数组的动态变化 const data = { name: 'aa', id: 001, information: { tel: '111xxxxx123', email: '12xxxxx@xx.com' } } data.id = { number: 001 }; ✅ data.id.number = 002 ❌ vue2 响应式 // 重新定义属性，监听起来 function defineReactive(target, key, value){ // 再次用value嵌套调用 observe ，若为对象，则进行进一步监听，若非value非对象则直接返回 observe(value) Object.defineProperty(target, key, { get(){ return value }, set(newVal){ // 针对对象新增加的值进行深度监听，如 data.id = { num: 101 }, 新增加的 num 也将能够被监听到 // observe(newVal) // value 一直在闭包中，此处设置完成后，下次get能够获取最新设置的值 if(newVal !== value){ value = newVal // 视图更新 updateView() } } }) } // 监听对象属性 function observe(target){ if(typeof target !== 'object' || target === null) { // 不是数组或对象 return target } // 如果是数组则修改该数组的原型 if(Array.isArray(target)){ target.__proto__ = arrProperty return } // 重新定义属性 for(let key in target) { defineReactive(target, key, target[key]) } } // 重新定义数组原型，加入触发更新的机制 const oldArrayProperty = Array.prototype // 创建新对象，原型指向oldArrayProperty const arrProperty = Object.create(oldArrayProperty) const methods = ['push','pop','shift','unshift','splice','sort'] methods.forEach(method =\u003e { arrProperty[method] = function(){ Array.prototype[method].call(this, ...arguments) updateView() } }) 使用： 1 定义数据 2 observe数据 3 对数据的属性进行修改 vue3 响应式 // 触发 effectFn添加行为 function effect(effectFn){ activeEffect = effectFn // 执行effectFn，触发 get effectFn() // 由于通过 set 触发副作用函数时也会导致 get 被触发， // 将 activeEffect 设为 null 避免重复添加副作用函数 activeEffect = null } // 存储所有副作用函数的对象 const fnList = new WeakMap() // 收集副作用函数 function track(target, key){ if(!activeEffect) return // 依次获取data对应的Map以及Map中key所对应的Set，有则将 activeEffect 加入，没有则新建后加入 let dataMap = fnList.get(target) if(!dataMap){ dataMap = new Map() fnList.set(target, dataMap) } let fnSet = dataMap.get(key) if(!fnSet){ fnSet = new Set() dataMap.set(key,fnSet) } fnSet.add(activeEffect) // activeEffect.deps.push(fnSet) } // 触发副作用函数 function trigger(target, key){ // 获取副作用函数集并执行 const dataMap = fnList.get(target) if(!dataMap) return const effectFns = dataMap.get(key) effectFns \u0026\u0026 effectFns.forEach(effectFn=\u003eeffectFn()) function observe_proxy(data){ const res = new Proxy(data, { get(target, key, receiver){ // 若修改的为嵌套对象，如 obj.a.b = 2，则 obj.a 触发 get， // 返回嵌套代理对象，完成嵌套对象代理 if(typeof target[key] === 'object' \u0026\u0026 target[key] !== null){ return observe_proxy(target[key]) } // **Reflect.get()**方法与从 对象 (target[propertyKey]) 中读取属性类似，但它是通过一个函数执行来操作的 const res = Reflect.get(target, key, receiver) // 将 effectFn 添加到 fnList 中 track(data, key) return res }, set(target, key, value, receiver){ // 静态方法 Reflect.set() 工作方式就像在一个对象上设置一个属性 let res = Reflect.set(target, key, value, receiver) // 执行 fnList 中所有副作用函数 trigger(target,key) return res } }) return res } const newData = ref(data) const newData = observe_proxy(data) const effectfn = () =\u003e {console.log(data.xxx}; effect(effectfn) weakmap key : target value(map) : target.key -\u003e set(fnSet) fnList: { [target1]: { [target.key]: Set(fn1, fn2), [target.key]: Set(fn4) }, [target2]: { [target.key]: Set(fn1, fn5) } }\nvue2 diff 算法 vue patch vnode 不存在，oldVnode 存在，就删掉 oldVnode vnode 存在，oldVnode 不存在，就创建 vnode 两个都存在的话，通过 sameVnode 函数对比是不是同一节点 如果是同一节点的话，通过 patchVnode 进行后续对比节点文本变化或子节点变化 如果不是同一节点，就把 vnode 挂载到 oldVnode 的父元素下 patchVnode 1、如果vnode和oldVnode完全一致，则什么都不做处理，直接返回 2、如果oldVnode和vnode都是静态节点，且具有相同的key，并且当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode复制到vnode上即可 3、如果vnode不是文本节点或注释节点 1）如果vnode的children和oldVnode的children都存在，且不完全相等，则调用updateChildren更新子节点 2）如果只有vnode存在子节点，则调用addVnodes添加这些子节点\n3）如果只有oldVnode存在子节点，则调用removeVnodes移除这些子节点 4）如果oldVnode和vnode都不存在子节点，但是oldVnode为文本节点或注释节点，则把oldVnode.elm的文本内容置为空 4、如果vnode是文本节点或注释节点，并且vnode.text和oldVnode.text不相等，则更新oldVnode的文本内容更新为vnode.text\nupdateChildren 双端算法 非理想情况 添加一个新节点 移除一个节点\nupdateChildren (parentElm, oldCh, newCh) { let oldStartIdx = 0, newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx let idxInOld let elmToMove let before while (oldStartIdx \u003c= oldEndIdx \u0026\u0026 newStartIdx \u003c= newEndIdx) { if (oldStartVnode == null) { // 对于vnode.key的比较，会把oldVnode = null oldStartVnode = oldCh[++oldStartIdx] }else if (oldEndVnode == null) { oldEndVnode = oldCh[--oldEndIdx] }else if (newStartVnode == null) { newStartVnode = newCh[++newStartIdx] }else if (newEndVnode == null) { newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldStartVnode, newStartVnode)) { patchVnode(oldStartVnode, newStartVnode) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] }else if (sameVnode(oldEndVnode, newEndVnode)) { patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldStartVnode, newEndVnode)) { patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldEndVnode, newStartVnode)) { patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] }else { // 使用key时的比较 if (oldKeyToIdx === undefined) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表 } idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) { api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] } else { elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) { api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) }else { patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) } newStartVnode = newCh[++newStartIdx] } } } if (oldStartIdx \u003e oldEndIdx) { before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) }else if (newStartIdx \u003e newEndIdx) { removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) } } vue3 diff算法 头和头比 尾和尾比 基于最长递增子序列进行移动/添加/删除 1 当前的索引为最长递增子序列中的值，也就是i === seq[j]，这说说明该节点不需要移动\n最长增长子序列 动态 贪心+二分 图解： https://leetcode.cn/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/\n初始化， 里面内容无所谓 和 原本的数组长度相同就行 用来存放索引 默认追加，标记当前一项（也就是最后一项）前一个对应的索引 假设有：[2,3,1,5,6,8,7,9,4] 为最新序列 -\u003e 按照上述结果得出的结论为：[ 2, 1, 8, 4, 6, 7 ] 替换并记录前驱节点，核心点：记录 “要替换的值的 前一个的索引” 以序列中最后一个值对应的索引向前追溯 最后一项肯定是正确的 export function getSequence(arr) { // 最终的结果是索引 const len = arr.length; const result = [0]; // 保存最长递增子序列的索引 以默认第0个位基准 // 【3.1】初始化， 里面内容无所谓 和 原本的数组长度相同就行 用来存放索引 const p = new Array(len).fill(0); let resultLastIndex; for (let i = 0; i \u003c len; i++) { // 【1】、找到索引先放进去 const arrI = arr[i]; // 获取数组中的每一项， // 0 在我们diff算法中代表新增 所以要忽略 if (arrI !== 0) { resultLastIndex = result[result.length - 1]; // 找到序列中的最后一项 if (arr[resultLastIndex] \u003c arrI) { // 取出序列中的最后一项对应的值 与当前项的值相比较 // 【3.2】默认追加，标记当前一项（也就是最后一项）前一个对应的索引 // p[i]就是当前一项 p[i] = resultLastIndex; result.push(i); // 记录索引 continue } // 第一步结束结果：console.log(getSequence([1,2,3,4,5,6,7,0])) // [0,1,2,3,4,5,6] // 【2】、二分查找 在结果集中找到比当前值大的 用当前值的索引将其替换掉 // result是递增序列 采用二分查找是最快的 let start = 0; let end = result.length - 1; // 二分查找 前后索引 while (start \u003c end) { // 最终 start = end 就停止了 let middle = ((start + end) / 2) | 0; // 向下取整 // 拿result中间值 和 当前项 比较 if (arr[result[middle]] \u003c arrI) { // 找比arrI大的值 或者等于arrI start = middle + 1; } else { end = middle; } } if (arrI \u003c arr[result[end]]) { // 当前项小于中间值就替换掉大的那一项 if (end \u003e 0) { // end \u003e 0 才需要替换 p[i]就是当前一项 p[i] = result[end - 1]; // 【3.3】替换并记录前驱节点，核心点：记录 “要替换的值的 前一个的索引” } result[end] = i; } // 第二步结束结果：console.log(getSequence([2,3,1,5,6,8,7,9,4] )) // 找到的索引：[ 2, 1, 8, 4, 6, 7 ] 找到的值：[1,3,4,6,7,9] 个数： 6 // 个数是对的但是 找到的值是不对的应该是 [2,3,5,6,7,9] } } // 3.3得到的结果 [0,0,undefined,1,3,4,4,6,1] // 【3.4】以序列中最后一个值对应的索引向前追溯 最后一项肯定是正确的 //找到的索引 [7,6,4,3,1,0] // 找到的值 [9,7,6,5,3,2] 和要找到的刚好相反 let i = result.length // 总长度 let last = result[i - 1] // 找到了最后一项 while (i-- \u003e 0) { // 倒序追溯 根据前驱节点一个个向前查找 result[i] = last // 最后一项肯定是正确的 last = p[last] // 重新赋值 } // console.log(getSequence([2,3,1,5,6,8,7,9,4] )) [0,1,3,4,6,7] return result } vue2模版编译 _s 是 toString，序列化成文本 _v 是 createTextVNode，创建一个 text virtual DOM 节点 _c 是 createElement，创建一个 element virtual DOM 节点 \u003cdiv\u003e \u003cheader\u003e \u003ch1\u003eI'm a template!\u003c/h1\u003e \u003c/header\u003e \u003cp v-if=\"message\"\u003e{{ message }}\u003c/p\u003e \u003cp v-else\u003eNo message.\u003c/p\u003e \u003c/div\u003e // 动态 function anonymous( ) { with(this){return _c('div',[_m(0),(message)?_c('p',[_v(_s(message))]):_c('p',[_v(\"No message.\")])])} } // 静态 _m(0): function anonymous( ) { with(this){return _c('header',[_c('h1',[_v(\"I'm a template!\")])])} } 在 Vue2 里每当触发更新的时候，不管元素是否参与更新，每次都会全部重新创建\nvue3渲染 引用尤雨溪： 为了实现这一点，编译器和运行时需要协同工作：编译器分析模板并生成带有优化提示的代码，而运行时尽可能获取提示并采用快速路径。这里有三个主要的优化：\n首先，在DOM树级别。我们注意到，在没有动态改变节点结构的模板指令（例如v-if和v-for）的情况下，节点结构保持完全静态。如果我们将一个模板分成由这些结构指令分隔的嵌套“块”，则每个块中的节点结构将再次完全静态。当我们更新块中的节点时，我们不再需要递归遍历DOM树 - 该块内的动态绑定可以在一个平面数组中跟踪。这种优化通过将需要执行的树遍历量减少一个数量级来规避虚拟DOM的大部分开销。 其次，编译器积极地检测模板中的静态节点、子树甚至数据对象，并在生成的代码中将它们提升到渲染函数之外。这样可以避免在每次渲染时重新创建这些对象，从而大大提高内存使用率并减少垃圾回收的频率。 第三，在元素级别。编译器还根据需要执行的更新类型，为每个具有动态绑定的元素生成一个优化标志。例如，具有动态类绑定和许多静态属性的元素将收到一个标志，提示只需要进行类检查。运行时将获取这些提示并采用专用的快速路径。 综合起来，这些技术大大改进了我们的渲染更新基准，Vue 3有时占用的CPU时间不到Vue 2的十分之一。 静态提升 静态节点的创建被拿到了渲染函数外面\nhttps://vue-next-template-explorer.netlify.app/#eyJzcmMiOiJcbjxkaXY+XG4gICAgICAgIDxoZWFkZXI+XG4gICAgICAgICAgPGgxPkknbSBhIHRlbXBsYXRlITwvaDE+XG4gICAgICAgICAgPHAgY2xhc3M9XCJoZWxsb1wiPmhlbGxvPC9wPlxuXG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHAgY2xhc3M9XCJoZWxsb1wiPmhlbGxvPC9wPlxuICAgICAgICAgIDxwIGNsYXNzPVwiaGVsbG9cIj5oZWxsbzwvcD5cbiAgICAgICAgICA8cCBjbGFzcz1cImhlbGxvXCI+aGVsbG88L3A+XG4gICAgICAgICAgPHAgY2xhc3M9XCJoZWxsb1wiPmhlbGxvPC9wPlxuICAgICAgICAgIDxwIGNsYXNzPVwiaGVsbG9cIj5oZWxsbzwvcD5cblxuICAgICAgICA8L2hlYWRlcj5cbiAgICAgICAgPGJ1dHRvbiBvbmNsaWNrPVwiaGFuZGxlQ2xpY2tcIj5hbm5pdTwvYnV0dG9uPlxuICAgICAgICA8cCB2LWlmPVwibWVzc2FnZVwiPnt7IG1lc3NhZ2UgfX08L3A+XG4gICAgICAgIDxwIHYtZWxzZT5ObyBtZXNzYWdlLjwvcD5cblxuICAgICAgICAgIDxwIGNsYXNzPVwiaGVsbG9cIj5oZWxsbzwvcD5cbiAgICAgICAgICA8cCBjbGFzcz1cImhlbGxvXCI+aGVsbG88L3A+XG4gICAgICAgICAgPHAgY2xhc3M9XCJoZWxsb1wiPmhlbGxvPC9wPlxuICAgICAgICAgIDxwIGNsYXNzPVwiaGVsbG9cIj5oZWxsbzwvcD5cbiAgICAgICAgICA8cCBjbGFzcz1cImhlbGxvXCI+aGVsbG88L3A+XG4gICAgICAgICAgPHAgY2xhc3M9XCJoZWxsb1wiPmhlbGxvPC9wPlxuICAgICAgPC9kaXY+Iiwic3NyIjpmYWxzZSwib3B0aW9ucyI6eyJob2lzdFN0YXRpYyI6dHJ1ZX19\n更新类型标记 export const enum PatchFlags { TEXT = 1 , // 动态文本节点 CLASS = 1 \u003c\u003c 1, // 2 动态class STYLE = 1 \u003c\u003c 2, // 4 动态style PROPS = 1 \u003c\u003c 3, // 8 除去class/style以外的动态属性 FULL_PROPS = 1 \u003c\u003c 4, // 16 有动态key属性的节点，当key改变时，需进行完整的diff比较 HYDRATE_EVENTS = 1 \u003c\u003c 5, // 32 有监听事件的节点 STABLE_FRAGMENT = 1 \u003c\u003c 6, // 64 一个不会改变子节点顺序的fragment (一个组件内多个根元素就会用fragment包裹) KEYED_FRAGMENT = 1 \u003c\u003c 7, // 128 带有key属性的fragment或部分子节点有key UNKEYEN_FRAGMENT = 1 \u003c\u003c 8, // 256 子节点没有key的fragment NEED_PATCH = 1 \u003c\u003c 9, // 512 一个节点只会进行非props比较 DYNAMIC_SLOTS = 1 \u003c\u003c 10, // 1024 动态slot HOISTED = -1, // 静态节点 BAIL = -2 // 表示 Diff 过程中不需要优化 } 树结构打平 \u003cdiv\u003e \u003c!-- root block --\u003e \u003cdiv\u003e...\u003c/div\u003e \u003c!-- 不会追踪 --\u003e \u003cdiv :id=\"id\"\u003e\u003c/div\u003e \u003c!-- 要追踪 --\u003e \u003cdiv\u003e \u003c!-- 不会追踪 --\u003e \u003cdiv\u003e{{ bar }}\u003c/div\u003e \u003c!-- 要追踪 --\u003e \u003c/div\u003e \u003c/div\u003e div (block root) - div 带有 :id 绑定 - div 带有 {{ bar }} 绑定 ","description":"vue2/3 差异","tags":["vue","2023"],"title":"Vue2 -\u003e Vue3","uri":"/learn/vue-diff/"},{"content":"标题语法 # h1 ## h2 以此类推 到6 记得有空格 内容 ====== 表示h1 内容 ------ 表示h2 = / - 数量任意 ### 内容 {#id的名字} =》 \u003ch3 id=\"id的名字\"\u003e内容\u003c/h3\u003e 好像有的不支持 段落 空行空出来就分段了\n换行 结尾空格\n字体样式 **加粗内容** __加粗内容__ *斜体* _斜体_ ***粗体且斜体*** ___粗体且斜体___ 引用 \u003e引用内容 \u003e \u003e放在一段里面的引用内容 \u003e \u003e\u003e引用里面引用 列表 有序列表 1. 内容 2. 内容 数字+. 前面数字是啥无所谓，但一定要是1开始 无序列表 - 列表 * 列表 + 列表 + 缩进列表 三个符号都可以 代码 代码\n分隔线 内容 ************** -------------- ______________ * - _ 都可以作为分隔符 a标签语法 [a标签显示内容](链接地址 \"title\")e.g. [百度](https://www.baidu.com \"百度\")\n图片 ![图片alt](图片链接 \"图片title\")\n转义字符\\ 支持html标签插入 表格 | Title1\t| Title2 | | --------- |\t-------- | | content1 | content2 | # 不一定要对齐 | Syntax | Description | Test Text | | :--- | :----: | ---: | | 左对齐 | 剧中 | 右对齐 | 注脚 [^数字或者单词] 不能包含空格和制表符 Here's a simple footnote,[^1] and here's a longer one.[^bignote] [^1]: 注脚1 [^bignote]: 注脚2 删除线 删除线\n任务列表 - [x] x代表这一项完成了 - [ ] 空白代表还没有 自动网址链接 链接如果希望他仅仅做展示，不希望点击后跳走，可以使用反引号http://xxxxx.com\n","description":"markdown 语法学习","tags":["学习杂记","2024"],"title":"Markdown 语法学习","uri":"/learn/markdown/"},{"content":"electron 实际上是 chromium浏览器环境 + node环境 + 原生api的环境\n但三种环境在electron里不是哪里都可以用的，他把js分成了主进程环境和渲染进程环境 每个 Electron 应用都有一个单一的主进程，作为应用程序的入口点。 主进程在 Node.js 环境中运行，这意味着它具有 require 模块和使用所有 Node.js API 的能力,也拥有访问原生api的能力\n等到渲染进程就不再拥有这个能力了，所以有preload,他在页面加载之前执行，在这里仍然拥有访问node的能力。 语境隔离（Context Isolation）意味着预加载脚本与渲染器的主要运行环境是隔离开来的，以避免泄漏任何具特权的 API 到您的网页内容代码中。就是说preload中挂在window上的内容在渲染进程里访问不到\n那如果要在渲染的页面里面拿到preload里定义的方法，这个时候就可以使用contextBridge 进程间通信 https://www.electronjs.org/zh/docs/latest/tutorial/ipc\n渲染进程发，主进程听（单向） preload 里 ipcRenderer.send html页面里面，调用window上的api里注册的方法，就是preload里面注册的方法名字 main.js 里 ipcMain.on监听\n渲染进程发，主进程听完返回，相互通信（双向） preload里 ipcRenderer.invoke() html页面里面，调用上面的方法，同样在window上 main.js里面ipcMain.handle()\n主进程发，渲染进程听 main.js里面 mainWindow.webContents.send mainWindow就是渲染进程实例 然后再preload里面进行 ipcRenderer.on听 最后再页面上 调用preload里面定义的方法，做逻辑处理\n如果这里想要通信回去，就在页面上调用的方法里面，再调用一个方法发送给主进程\n两个渲染器进程 之能拿主进程做中转\n","description":"Electron 主进程 渲染进程","tags":["electron","2024"],"title":"Electron 主进程 渲染进程","uri":"/learn/electron-communication/"},{"content":"前提 毕业以后我的工资全部都存在工商银行的卡里，一般默认存进去的钱自动存活期，但是今年五月发现并没有，所以萌生了理财的想法。\n余额宝里目前有一些钱，然后就是把上面工商的钱存了定期，但是利率1.7有点低。理财产品看不懂，想先找一本书来看看，听说小狗钱钱可以入门。\n读书笔记 72定律\n72 除以投资的年收益率的百分比，得出的数字就是这笔钱翻一倍所要的年数\n72公式也可以用来帮助我们计算通货膨胀。它可以告诉我们，在一定通货膨胀率下，我们的钱在多长时间后会贬值一半。\n比如按72除以3%的通货膨胀率计算，得到24，就是说24年以后，你的钱只值现在的一半。\n记录 书里还提到一个观点时金钱不能使人变得幸福，幸福的人得到金钱会变得更加幸福，但是悲惨的人不会因为得到金钱而变得幸福。感觉很有道理，幸福的能力是自己给的，金钱固然能提升人的生活质量但是幸福的能力还是要靠自己来创造。\n书中对基金的概念也有了一个比较清晰易懂的介绍，基金是经理人受限要求购买至少二十种股票，然后把风险平坦，保证最终受益。书中的观点是行业都会迎来低谷期，但只有低谷期不卖出，就不会亏损，然后总会迎来行业回暖。\n书中主角对自己的财产进行了比例划分来进行管理，她将50%作为会下单的鹅，可持续发展，钱生钱。40%作为梦想基金来实现目标，所以在最开始就设立了要实现的目标。10%作为消费。\n我以前总是会把前面这90%搞混在一起，看起来好像没什么区别，但是风险小了，收益也小了。很多时候目标是攒钱，但是10%的界限又会越过，所以一个清晰的比例也有助于我对自己的钱有一个比较清晰的掌控。 我和主角的比例可能不太一样，我目前对理财有了一个大概的基础认知，算是入门了，我还要再学习一下相关知识。\n","description":"小狗钱钱-理财入门第一本","tags":["book","2024"],"title":"小狗钱钱-入门第一本","uri":"/readothers/finance-first/"},{"content":"安装 https://gohugo.io/installation/windows/直接用 scoop 安装最方便 go 安装msi文件运行就可以了\n新建 hugo new site [网站名字]\n挑选一个主题 https://themes.gohugo.io/\ngit submodule add [主题的github地址]\n在 hugo.toml 里面定义主题 theme = '主题名字'\nhugo server 启动\nhugo server -D 预览\n新建文章 hugo new content posts/my-first-post.md\nhugo 打包文件 会放到 public 目录下面\ngithub page 创建一个仓库 命名 username.github.io 然后把远程仓库拉到本地 git clone 远程仓库 把上面 public 目录下的所有文件复制过来 提交 推送远程仓库 访问 username.github.io hugo.toml 文件 # 设置默认语言为简体中文 defaultContentLanguage = 'zh-cn' # 要注意配置文件的 url 要更改成github page的路径！！！ baseURL = 'https://yjmbc.github.io/' [Params] # 指示网站是否为自托管 selfHosted = true # 设置日期格式为\"2006-01-02\"，即年-月-日 dateFormat = \"2006-01-02\" # 是否显示文章的预估阅读时间 readingTime = true # 是否在文章末尾显示字数统计 wordCount = true # 是否使用highlight.js进行代码高亮 useHLJS = true # 是否在文章底部显示相关文章推荐 showRelatedPosts = true # 是否显示文章的最后修改时间 Lastmod = true # 分页设置，每页显示的文章数量 pagination = \"10\" # 是否在文章页面隐藏作者信息 hideAuthor = true # 网站描述，可自定义内容 description=\"Your can add your website description here.\" # 是否启用基于Lunr的客户端搜索功能 lunrSearch = true # 预览卡片中图片的位置，此处设为显示在底部 previewCardImagePlacement = \"bottom\" # 用来设置右上角的导航栏内容, url 对应 content 目录下的路径 [[menu.main]] name = \"首页\" url = \"/\" weight = 1 # weight 用来定义导航栏的展示顺序，数值越小越靠前 [[menu.main]] name = \"学习记录\" url = \"/learn/\" weight = 2 文章开头定义 使用主题： lightbi-hugo\n--- title: hugo 实践记录 date: 2024-06-14 tags: [\"hugo\"] image : \"/img/work/bird.jpg\" Description : \"hugo 构建个人博客页并部署到 github page 全过程简便记录...\" --- tags 标签可以定义文章属于哪个标签，然后在 tags页面下按照标签展示img 是缩略卡片展示的图片内容以及内容页的展示图片，路径为themes/主题名字/assets/img下的路径\n文章导入过程 由于习惯用语雀进行记录，所以文章可以使用语雀进行编写，导出成markdown文件再放进来 提交 blog 项目一个仓库A，打包之后放到 github page 上的文件一个仓库B\nA 本地修改完成之后，hugo打包生成静态资源 # Hugo生成的静态文件 public/ # Hugo缓存目录 resources/ cache/ $hugocfg/workDir/ # 编译相关的临时文件 dist/ out/ build/ # Go模块的缓存 go.sum pkg/mod/ #编辑器和IDE相关的忽略规则 .idea/ .vscode/ *.sublime-workspace *.swp *.swo # 个人身份认证或密钥文件（确保不在版本控制中泄露敏感信息） id_rsa id_rsa.pub known_hosts # 其他可能不需要的文件类型 .DS_Store Thumbs.db *.log *.bak *.tmp 提交A到代码仓库 删除 github page 关联仓库B下所有代码 B重新关联 远程仓库 复制A public 文件夹下的内容到该项目B下 提交B到代码仓库 hugo time=$(date \"+%Y-%m-%d %H:%M:%S\") echo $time git add . git commit -m \"feat: 自动提交hugo代码 $time\" git push cd ../yjmbc.github.io/ rm -rf ./* git init git remote add origin https://github.com/yjmbc/yjmbc.github.io.git cd ../my-blog/ cp -r ./public/* ../yjmbc.github.io/ cd ../yjmbc.github.io/ git checkout main git add . git commit -m \"feat: 自动提交hugo public代码 $time\" git push 运行 build.sh 文件\n","description":"hugo 构建个人博客页并部署到 github page 全过程简便记录...","tags":["hugo","2024"],"title":"hugo 实践记录","uri":"/work/hugo-start/"}]
