[{"content":"一 反馈按钮 1 使用 drag event 来实现 主要思路： dragstart 的时候设置定时器隐藏原本的按钮 不然隐藏之后无法触发 dragstart 事件 drag 期间修改鼠标的样式，原本默认是 copy 的鼠标样式 dragend 的时候获取鼠标的位置，设置 style.top ，定时器恢复按钮的显示\n实践发现，完全使用 drag event 不用针对点击事件进行额外的处理，拖拽流程也很流畅，但是如果不采用全屏都是可拖拽区域的写法，拖拽的时候会出现明显的回弹，为了避免回弹，使用全屏都是可拖拽区域的方法，又会导致鼠标的 copy 样式无法完全隐藏，（可以隐藏，但是偶尔太快拖动的时候会出现）这个问题在拖拽库中也可以观察到，例如: http://alloyteam.github.io/AlloyFinger/ 所以出于这一点的原因不采用 drag event 来实现\n2 使用 mouse event 来实现 主要思路： 仿造 touch 事件来完成（ 这里的距离计算和下面vconsole中的计算方式是一样的 ） mousedown 的时候 记录鼠标的初始位置坐标 同时在 document 上重写 mouseup mousemove 事件\nbutton.onmousedown = (e) =\u003e { e.preventDefault(); // 记录鼠标点下去的开始位置 button.setAttribute('startX', `${e.clientX || 0}`); button.setAttribute('startY', `${e.clientY || 0}`); // 同时修改 mouseup mousemove 事件 document.onmousemove = onMouseMove; document.onmouseup = onMouseUp; } mousemove 期间实时计算偏移量以及最终的坐标 同时消除 style.pointerEvent = ’none’ 避免 mousedown 触发click 事件\nconst onMouseMove = (e) =\u003e { e.preventDefault(); // 计算鼠标的移动距离，修改按钮的实时位置 calculateXY(e); // 取消鼠标事件，避免触发点击事件 button.style.pointerEvents = 'none'; } mouseup 的时候，记录到本地 localStorage 里面 同时 style.pointerEvent = null 恢复点击事件的触发\nconst onMouseUp = (e) =\u003e { e.preventDefault(); // 把刚刚移动的时候设置的事件取消掉，恢复点击事件 button.style.pointerEvents = null; // 把最后的位置记录到本地，这里是为了页面刷新之后能恢复上一次移动的位置 window.localStorage.setItem('button_position',`${button.getAttribute('endX')},${button.getAttribute('endY')}`) document.onmouseup = null; document.onmousemove = null; } 采用鼠标事件模拟，相比于 drag event ，代码的量变大了，但是几乎没有用户能感知到的缺点，拖拽是流畅的，没有回弹效果，鼠标样式也是合理常见的，因此最终采用 mouse event 来实现，这里的实现方法也尝试让AI 先写，然后根据移动端的实现，做人工修改，尽量修改成一样的逻辑，避免代码的冗余，提高代码的复用率。\nconst button = document.querySelector('button'); button.style.position = 'absolute'; button.setAttribute('endX', 0); button.setAttribute('endY', 0); const getPosition = () =\u003e { // 如果不是第一次移动，那么就会在localstorage里面记录上一次的 right bottom let [x, y] = window.localStorage.getItem('button_position')?.split(',') || []; // 如果第一次移动，在这里设置开始的默认位置，这里默认右下角 if (!x \u0026\u0026 !y) { x = 0; y = 0; } return [+x, +y]; } // 对边界进行验证，最终返回的就是 right , bottom 的值 const setSafePosition = (x,y) =\u003e { // 先获取窗口的最大宽高 const windowWidth = Math.max(document.documentElement.offsetWidth, window.innerWidth || 0); const windowHeight = Math.max(document.documentElement.offsetHeight, window.innerHeight || 0); // 如果原来的 right 加上了按钮现在的offsetWidth,可以理解为加上了自己的宽度，如果超出去了，就设置为边界 if (x + button.offsetWidth \u003e windowWidth) { x = windowWidth - button.offsetWidth; } // 同理 if (y + button.offsetHeight \u003e windowHeight) { y = windowHeight - button.offsetHeight; } // 这里可以在按钮上增加属性来规定按钮是否要贴着一侧的边 x = x \u003c 0 ? 0 : x; y = y \u003c 0 ? 0 : y; if (x \u003e= 0) { button.style.right = x + 'px'; } // 这个地方换成百分比是因为，窗口大小变化的时候，这个会展示出现问题 if (y \u003e= 0) { button.style.bottom = ((y / windowHeight) * 100) + '%' } return [x, y]; } // 初始化的时候获取上一次的位置 const [x, y] = getPosition(); // 设置按钮的位置 setSafePosition(x,y); /** * 移动过程中实时更新坐标,同时判断是否越界 * @param {MouseEvent} e */ const calculateXY = (e) =\u003e { // 计算移动的距离 const moveX = e.clientX - +button.getAttribute('startX'); const moveY = e.clientY - +button.getAttribute('startY'); // 获取当前位置的 right 边距， // 如果用户已经移动过，在localStorage里面读取 // 没有移动过使用\t默认的初始值，一般在右下角，除非设置了按钮刚开始所在的位置 const [x, y] = getPosition(); const [right, bottom] = setSafePosition(x - moveX, y - moveY); // 记录一下结束的位置 button.setAttribute('endX', `${right}`); button.setAttribute('endY', `${bottom}`); } /** * * @param {MouseEvent} e */ const onMouseMove = (e) =\u003e { e.preventDefault(); // 获取鼠标的移动距离 calculateXY(e); // 取消鼠标事件，避免触发点击事件 button.style.pointerEvents = 'none'; } /** * * @param {MouseEvent} e */ const onMouseUp = (e) =\u003e { e.preventDefault(); // 把刚刚移动的设置的事件取消掉，恢复点击事件 button.style.pointerEvents = null; // 把最后的位置记录到本地，这里是为了页面刷新之后能恢复上一次移动的位置 window.localStorage.setItem('button_position',`${button.getAttribute('endX')},${button.getAttribute('endY')}`) document.onmouseup = null; document.onmousemove = null; } /** * * @param {MouseEvent} e */ button.onmousedown = (e) =\u003e { e.preventDefault(); // 记录鼠标点下去的开始位置 button.setAttribute('startX', `${e.clientX || 0}`); button.setAttribute('startY', `${e.clientY || 0}`); // 同时修改 mouseup mousemove 事件 document.onmousemove = onMouseMove; document.onmouseup = onMouseUp; } 二 vconsole移动端实现(开源) https://hd.qxwz.com/ddlogin?vconsole=1\nvalue: function() { var e = this , t = i.default.one(\".vc-switch\", e.$dom); i.default.bind(t, \"touchstart\", function(t) { e.switchPos.startX = t.touches[0].pageX, e.switchPos.startY = t.touches[0].pageY }), i.default.bind(t, \"touchend\", function(t) { e.switchPos.x = e.switchPos.endX, e.switchPos.y = e.switchPos.endY, e.switchPos.startX = 0, e.switchPos.startY = 0, r.setStorage(\"switch_x\", e.switchPos.x), r.setStorage(\"switch_y\", e.switchPos.y) }), i.default.bind(t, \"touchmove\", function(o) { if (o.touches.length \u003e 0) { var n = o.touches[0].pageX - e.switchPos.startX , r = o.touches[0].pageY - e.switchPos.startY , i = e.switchPos.x - n , a = e.switchPos.y - r; i + t.offsetWidth \u003e document.documentElement.offsetWidth \u0026\u0026 (i = document.documentElement.offsetWidth - t.offsetWidth), a + t.offsetHeight \u003e document.documentElement.offsetHeight \u0026\u0026 (a = document.documentElement.offsetHeight - t.offsetHeight), i \u003c 0 \u0026\u0026 (i = 0), a \u003c 0 \u0026\u0026 (a = 0), t.style.right = i + \"px\", t.style.bottom = a + \"px\", e.switchPos.endX = i, e.switchPos.endY = a, o.preventDefault() } }), 1 touches 数组 https://www.jb51.net/article/261609.htm https://developer.mozilla.org/zh-CN/docs/Web/API/TouchEvent\ntouches 所有接触屏幕的接触点 targetTouches 针对目标元素上存在的触摸点 changedTouches 屏幕上针对上一次接触事件，状态发生改变的触摸点\ntouches按照触摸顺序进行存储，如果第一个手指先放好，用另一个手指移动则无法移动，因为取到了第一个手指的属性，但是基本不影响使用。\n2 主要思路 主要计算元素的 right 和 bottom 值来进行定位 以横向移动为例 touchstart 开始就记录下来初始位置的 clientX touchmove\n- 开始记录下来第一个触点的 clientX ，用移动中的位置减去初始位置获得实时的移动距离 moveX - 获取当前位置的 right 边距，如果用户已经移动过，在localStorage里面读取，没有移动过使用\t默认的初始值，一般在右下角，除非传递了初始值。 - 然后用当前位置的 right 边距减去移动的距离，获得移动过后的 right 距离 - 判断 right 距离是否超出屏幕，给元素 style.right 进行赋值 touchend 在localStorage里面记录当前的 right , bottom\n3 存在问题以及改进空间 当前获取的触点坐标取了数组元素的第一个，但是 touches 数组主要是以手指触碰屏幕的顺序进入数组的，如果第一根手指放在了屏幕的任意地方，那么第二根手指去移动是移动不了的。\n解决方案的话，可以通过 touch 对象里面的 target 对象来判断当前的作用对象是不是目标对象，然后以此进行数组的查找，但是会很冗余，一般情况下用户不会放两根手指在手机上，尤其是在屏幕上移动手指的时候。\n","description":"拖拽功能实现记录","tags":["2023"],"title":"拖拽实现记录","uri":"/work/drag/"},{"content":"api 风格 选项式api 组合式api 组合式api 生命周期钩子对比 vue2 vue3 beforeCreate / created setup beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeDestroy onBeforeUnmount destroyed onUnmounted setup(props, context) { // Attribute (非响应式对象，等同于 $attrs) context.attrs // 插槽 (非响应式对象，等同于 $slots) context.slots // 触发事件 (方法，等同于 $emit) context.emit // 暴露公共 property (函数) context.expose return {} } 响应式 对象和数组的动态变化 const data = { name: 'aa', id: 001, information: { tel: '111xxxxx123', email: '12xxxxx@xx.com' } } data.id = { number: 001 }; ✅ data.id.number = 002 ❌ vue2 响应式 // 重新定义属性，监听起来 function defineReactive(target, key, value){ // 再次用value嵌套调用 observe ，若为对象，则进行进一步监听，若非value非对象则直接返回 observe(value) Object.defineProperty(target, key, { get(){ return value }, set(newVal){ // 针对对象新增加的值进行深度监听，如 data.id = { num: 101 }, 新增加的 num 也将能够被监听到 // observe(newVal) // value 一直在闭包中，此处设置完成后，下次get能够获取最新设置的值 if(newVal !== value){ value = newVal // 视图更新 updateView() } } }) } // 监听对象属性 function observe(target){ if(typeof target !== 'object' || target === null) { // 不是数组或对象 return target } // 如果是数组则修改该数组的原型 if(Array.isArray(target)){ target.__proto__ = arrProperty return } // 重新定义属性 for(let key in target) { defineReactive(target, key, target[key]) } } // 重新定义数组原型，加入触发更新的机制 const oldArrayProperty = Array.prototype // 创建新对象，原型指向oldArrayProperty const arrProperty = Object.create(oldArrayProperty) const methods = ['push','pop','shift','unshift','splice','sort'] methods.forEach(method =\u003e { arrProperty[method] = function(){ Array.prototype[method].call(this, ...arguments) updateView() } }) 使用： 1 定义数据 2 observe数据 3 对数据的属性进行修改 vue3 响应式 // 触发 effectFn添加行为 function effect(effectFn){ activeEffect = effectFn // 执行effectFn，触发 get effectFn() // 由于通过 set 触发副作用函数时也会导致 get 被触发， // 将 activeEffect 设为 null 避免重复添加副作用函数 activeEffect = null } // 存储所有副作用函数的对象 const fnList = new WeakMap() // 收集副作用函数 function track(target, key){ if(!activeEffect) return // 依次获取data对应的Map以及Map中key所对应的Set，有则将 activeEffect 加入，没有则新建后加入 let dataMap = fnList.get(target) if(!dataMap){ dataMap = new Map() fnList.set(target, dataMap) } let fnSet = dataMap.get(key) if(!fnSet){ fnSet = new Set() dataMap.set(key,fnSet) } fnSet.add(activeEffect) // activeEffect.deps.push(fnSet) } // 触发副作用函数 function trigger(target, key){ // 获取副作用函数集并执行 const dataMap = fnList.get(target) if(!dataMap) return const effectFns = dataMap.get(key) effectFns \u0026\u0026 effectFns.forEach(effectFn=\u003eeffectFn()) function observe_proxy(data){ const res = new Proxy(data, { get(target, key, receiver){ // 若修改的为嵌套对象，如 obj.a.b = 2，则 obj.a 触发 get， // 返回嵌套代理对象，完成嵌套对象代理 if(typeof target[key] === 'object' \u0026\u0026 target[key] !== null){ return observe_proxy(target[key]) } // **Reflect.get()**方法与从 对象 (target[propertyKey]) 中读取属性类似，但它是通过一个函数执行来操作的 const res = Reflect.get(target, key, receiver) // 将 effectFn 添加到 fnList 中 track(data, key) return res }, set(target, key, value, receiver){ // 静态方法 Reflect.set() 工作方式就像在一个对象上设置一个属性 let res = Reflect.set(target, key, value, receiver) // 执行 fnList 中所有副作用函数 trigger(target,key) return res } }) return res } const newData = ref(data) const newData = observe_proxy(data) const effectfn = () =\u003e {console.log(data.xxx}; effect(effectfn) weakmap key : target value(map) : target.key -\u003e set(fnSet) fnList: { [target1]: { [target.key]: Set(fn1, fn2), [target.key]: Set(fn4) }, [target2]: { [target.key]: Set(fn1, fn5) } }\nvue2 diff 算法 vue patch vnode 不存在，oldVnode 存在，就删掉 oldVnode vnode 存在，oldVnode 不存在，就创建 vnode 两个都存在的话，通过 sameVnode 函数对比是不是同一节点 如果是同一节点的话，通过 patchVnode 进行后续对比节点文本变化或子节点变化 如果不是同一节点，就把 vnode 挂载到 oldVnode 的父元素下 patchVnode 1、如果vnode和oldVnode完全一致，则什么都不做处理，直接返回 2、如果oldVnode和vnode都是静态节点，且具有相同的key，并且当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode复制到vnode上即可 3、如果vnode不是文本节点或注释节点 1）如果vnode的children和oldVnode的children都存在，且不完全相等，则调用updateChildren更新子节点 2）如果只有vnode存在子节点，则调用addVnodes添加这些子节点\n3）如果只有oldVnode存在子节点，则调用removeVnodes移除这些子节点 4）如果oldVnode和vnode都不存在子节点，但是oldVnode为文本节点或注释节点，则把oldVnode.elm的文本内容置为空 4、如果vnode是文本节点或注释节点，并且vnode.text和oldVnode.text不相等，则更新oldVnode的文本内容更新为vnode.text\nupdateChildren 双端算法 非理想情况 添加一个新节点 移除一个节点\nupdateChildren (parentElm, oldCh, newCh) { let oldStartIdx = 0, newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx let idxInOld let elmToMove let before while (oldStartIdx \u003c= oldEndIdx \u0026\u0026 newStartIdx \u003c= newEndIdx) { if (oldStartVnode == null) { // 对于vnode.key的比较，会把oldVnode = null oldStartVnode = oldCh[++oldStartIdx] }else if (oldEndVnode == null) { oldEndVnode = oldCh[--oldEndIdx] }else if (newStartVnode == null) { newStartVnode = newCh[++newStartIdx] }else if (newEndVnode == null) { newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldStartVnode, newStartVnode)) { patchVnode(oldStartVnode, newStartVnode) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] }else if (sameVnode(oldEndVnode, newEndVnode)) { patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldStartVnode, newEndVnode)) { patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldEndVnode, newStartVnode)) { patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] }else { // 使用key时的比较 if (oldKeyToIdx === undefined) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表 } idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) { api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] } else { elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) { api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) }else { patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) } newStartVnode = newCh[++newStartIdx] } } } if (oldStartIdx \u003e oldEndIdx) { before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) }else if (newStartIdx \u003e newEndIdx) { removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) } } vue3 diff算法 头和头比 尾和尾比 基于最长递增子序列进行移动/添加/删除 1 当前的索引为最长递增子序列中的值，也就是i === seq[j]，这说说明该节点不需要移动\n最长增长子序列 动态 贪心+二分 图解： https://leetcode.cn/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/\n初始化， 里面内容无所谓 和 原本的数组长度相同就行 用来存放索引 默认追加，标记当前一项（也就是最后一项）前一个对应的索引 假设有：[2,3,1,5,6,8,7,9,4] 为最新序列 -\u003e 按照上述结果得出的结论为：[ 2, 1, 8, 4, 6, 7 ] 替换并记录前驱节点，核心点：记录 “要替换的值的 前一个的索引” 以序列中最后一个值对应的索引向前追溯 最后一项肯定是正确的 export function getSequence(arr) { // 最终的结果是索引 const len = arr.length; const result = [0]; // 保存最长递增子序列的索引 以默认第0个位基准 // 【3.1】初始化， 里面内容无所谓 和 原本的数组长度相同就行 用来存放索引 const p = new Array(len).fill(0); let resultLastIndex; for (let i = 0; i \u003c len; i++) { // 【1】、找到索引先放进去 const arrI = arr[i]; // 获取数组中的每一项， // 0 在我们diff算法中代表新增 所以要忽略 if (arrI !== 0) { resultLastIndex = result[result.length - 1]; // 找到序列中的最后一项 if (arr[resultLastIndex] \u003c arrI) { // 取出序列中的最后一项对应的值 与当前项的值相比较 // 【3.2】默认追加，标记当前一项（也就是最后一项）前一个对应的索引 // p[i]就是当前一项 p[i] = resultLastIndex; result.push(i); // 记录索引 continue } // 第一步结束结果：console.log(getSequence([1,2,3,4,5,6,7,0])) // [0,1,2,3,4,5,6] // 【2】、二分查找 在结果集中找到比当前值大的 用当前值的索引将其替换掉 // result是递增序列 采用二分查找是最快的 let start = 0; let end = result.length - 1; // 二分查找 前后索引 while (start \u003c end) { // 最终 start = end 就停止了 let middle = ((start + end) / 2) | 0; // 向下取整 // 拿result中间值 和 当前项 比较 if (arr[result[middle]] \u003c arrI) { // 找比arrI大的值 或者等于arrI start = middle + 1; } else { end = middle; } } if (arrI \u003c arr[result[end]]) { // 当前项小于中间值就替换掉大的那一项 if (end \u003e 0) { // end \u003e 0 才需要替换 p[i]就是当前一项 p[i] = result[end - 1]; // 【3.3】替换并记录前驱节点，核心点：记录 “要替换的值的 前一个的索引” } result[end] = i; } // 第二步结束结果：console.log(getSequence([2,3,1,5,6,8,7,9,4] )) // 找到的索引：[ 2, 1, 8, 4, 6, 7 ] 找到的值：[1,3,4,6,7,9] 个数： 6 // 个数是对的但是 找到的值是不对的应该是 [2,3,5,6,7,9] } } // 3.3得到的结果 [0,0,undefined,1,3,4,4,6,1] // 【3.4】以序列中最后一个值对应的索引向前追溯 最后一项肯定是正确的 //找到的索引 [7,6,4,3,1,0] // 找到的值 [9,7,6,5,3,2] 和要找到的刚好相反 let i = result.length // 总长度 let last = result[i - 1] // 找到了最后一项 while (i-- \u003e 0) { // 倒序追溯 根据前驱节点一个个向前查找 result[i] = last // 最后一项肯定是正确的 last = p[last] // 重新赋值 } // console.log(getSequence([2,3,1,5,6,8,7,9,4] )) [0,1,3,4,6,7] return result } vue2模版编译 _s 是 toString，序列化成文本 _v 是 createTextVNode，创建一个 text virtual DOM 节点 _c 是 createElement，创建一个 element virtual DOM 节点 \u003cdiv\u003e \u003cheader\u003e \u003ch1\u003eI'm a template!\u003c/h1\u003e \u003c/header\u003e \u003cp v-if=\"message\"\u003e{{ message }}\u003c/p\u003e \u003cp v-else\u003eNo message.\u003c/p\u003e \u003c/div\u003e // 动态 function anonymous( ) { with(this){return _c('div',[_m(0),(message)?_c('p',[_v(_s(message))]):_c('p',[_v(\"No message.\")])])} } // 静态 _m(0): function anonymous( ) { with(this){return _c('header',[_c('h1',[_v(\"I'm a template!\")])])} } 在 Vue2 里每当触发更新的时候，不管元素是否参与更新，每次都会全部重新创建\nvue3渲染 引用尤雨溪： 为了实现这一点，编译器和运行时需要协同工作：编译器分析模板并生成带有优化提示的代码，而运行时尽可能获取提示并采用快速路径。这里有三个主要的优化：\n首先，在DOM树级别。我们注意到，在没有动态改变节点结构的模板指令（例如v-if和v-for）的情况下，节点结构保持完全静态。如果我们将一个模板分成由这些结构指令分隔的嵌套“块”，则每个块中的节点结构将再次完全静态。当我们更新块中的节点时，我们不再需要递归遍历DOM树 - 该块内的动态绑定可以在一个平面数组中跟踪。这种优化通过将需要执行的树遍历量减少一个数量级来规避虚拟DOM的大部分开销。 其次，编译器积极地检测模板中的静态节点、子树甚至数据对象，并在生成的代码中将它们提升到渲染函数之外。这样可以避免在每次渲染时重新创建这些对象，从而大大提高内存使用率并减少垃圾回收的频率。 第三，在元素级别。编译器还根据需要执行的更新类型，为每个具有动态绑定的元素生成一个优化标志。例如，具有动态类绑定和许多静态属性的元素将收到一个标志，提示只需要进行类检查。运行时将获取这些提示并采用专用的快速路径。 综合起来，这些技术大大改进了我们的渲染更新基准，Vue 3有时占用的CPU时间不到Vue 2的十分之一。 静态提升 静态节点的创建被拿到了渲染函数外面\nhttps://vue-next-template-explorer.netlify.app/#eyJzcmMiOiJcbjxkaXY+XG4gICAgICAgIDxoZWFkZXI+XG4gICAgICAgICAgPGgxPkknbSBhIHRlbXBsYXRlITwvaDE+XG4gICAgICAgICAgPHAgY2xhc3M9XCJoZWxsb1wiPmhlbGxvPC9wPlxuXG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHA+aGVsbG88L3A+XG4gICAgICAgICAgPHAgY2xhc3M9XCJoZWxsb1wiPmhlbGxvPC9wPlxuICAgICAgICAgIDxwIGNsYXNzPVwiaGVsbG9cIj5oZWxsbzwvcD5cbiAgICAgICAgICA8cCBjbGFzcz1cImhlbGxvXCI+aGVsbG88L3A+XG4gICAgICAgICAgPHAgY2xhc3M9XCJoZWxsb1wiPmhlbGxvPC9wPlxuICAgICAgICAgIDxwIGNsYXNzPVwiaGVsbG9cIj5oZWxsbzwvcD5cblxuICAgICAgICA8L2hlYWRlcj5cbiAgICAgICAgPGJ1dHRvbiBvbmNsaWNrPVwiaGFuZGxlQ2xpY2tcIj5hbm5pdTwvYnV0dG9uPlxuICAgICAgICA8cCB2LWlmPVwibWVzc2FnZVwiPnt7IG1lc3NhZ2UgfX08L3A+XG4gICAgICAgIDxwIHYtZWxzZT5ObyBtZXNzYWdlLjwvcD5cblxuICAgICAgICAgIDxwIGNsYXNzPVwiaGVsbG9cIj5oZWxsbzwvcD5cbiAgICAgICAgICA8cCBjbGFzcz1cImhlbGxvXCI+aGVsbG88L3A+XG4gICAgICAgICAgPHAgY2xhc3M9XCJoZWxsb1wiPmhlbGxvPC9wPlxuICAgICAgICAgIDxwIGNsYXNzPVwiaGVsbG9cIj5oZWxsbzwvcD5cbiAgICAgICAgICA8cCBjbGFzcz1cImhlbGxvXCI+aGVsbG88L3A+XG4gICAgICAgICAgPHAgY2xhc3M9XCJoZWxsb1wiPmhlbGxvPC9wPlxuICAgICAgPC9kaXY+Iiwic3NyIjpmYWxzZSwib3B0aW9ucyI6eyJob2lzdFN0YXRpYyI6dHJ1ZX19\n更新类型标记 export const enum PatchFlags { TEXT = 1 , // 动态文本节点 CLASS = 1 \u003c\u003c 1, // 2 动态class STYLE = 1 \u003c\u003c 2, // 4 动态style PROPS = 1 \u003c\u003c 3, // 8 除去class/style以外的动态属性 FULL_PROPS = 1 \u003c\u003c 4, // 16 有动态key属性的节点，当key改变时，需进行完整的diff比较 HYDRATE_EVENTS = 1 \u003c\u003c 5, // 32 有监听事件的节点 STABLE_FRAGMENT = 1 \u003c\u003c 6, // 64 一个不会改变子节点顺序的fragment (一个组件内多个根元素就会用fragment包裹) KEYED_FRAGMENT = 1 \u003c\u003c 7, // 128 带有key属性的fragment或部分子节点有key UNKEYEN_FRAGMENT = 1 \u003c\u003c 8, // 256 子节点没有key的fragment NEED_PATCH = 1 \u003c\u003c 9, // 512 一个节点只会进行非props比较 DYNAMIC_SLOTS = 1 \u003c\u003c 10, // 1024 动态slot HOISTED = -1, // 静态节点 BAIL = -2 // 表示 Diff 过程中不需要优化 } 树结构打平 \u003cdiv\u003e \u003c!-- root block --\u003e \u003cdiv\u003e...\u003c/div\u003e \u003c!-- 不会追踪 --\u003e \u003cdiv :id=\"id\"\u003e\u003c/div\u003e \u003c!-- 要追踪 --\u003e \u003cdiv\u003e \u003c!-- 不会追踪 --\u003e \u003cdiv\u003e{{ bar }}\u003c/div\u003e \u003c!-- 要追踪 --\u003e \u003c/div\u003e \u003c/div\u003e div (block root) - div 带有 :id 绑定 - div 带有 {{ bar }} 绑定 ","description":"vue2/3 差异","tags":["vue","2023"],"title":"Vue2 -\u003e Vue3","uri":"/learn/vue-diff/"},{"content":"vue3 流程 1 预处理 头头尾尾 2 新增节点 oldEnd \u003c j 成立，说明在预处理时，所有旧子节点都处理完毕了 newEnd \u003e= j 成立，说明预处理后，新的一组子节点中，存在未被处理的节点，这些节点就是新增的节点 3 删除节点 oldend \u003e= j 存在未被处理的节点 newend \u003c j 新节点 已经都处理过了 4 重新编号之前，最长递增子序列对应的是 新节点在旧节点列表中的为止 而编号之后，最长递增子序列对应的是 具体的节点\n最长增长子序列 动态 贪心+二分 得到正确顺序的核心是记录前驱节点 React fiber 1 流程 JS 是单线程的，浏览器是多线程的 对于多线程的浏览器而言，它除了要处理 JS这个线程，它还要处理定时器，网络请求，UI渲染…这些线程。 问题：浏览器中JS线程与UI线程互斥，假设这段代码运行的时间很久，那么浏览器就必须一直等待，严重情况下浏览器还可能失去响应 Fiber vs Stack Demo\n卡顿，掉帧 人眼：24帧/秒 递归 dom 树\n2 fiber 从运行机制上来解释，fiber是一种流程让出机制，它能让react中的同步渲染进行中断，并将渲染的控制权让回浏览器，从而达到不阻塞浏览器渲染的目的。 从数据角度来解释，fiber能细化成一种数据结构，或者一个执行单元。 传统： fiber： 数据结构：\nconst fiber = { stateNode,// dom节点实例 child,// 当前节点所关联的子节点 sibling,// 当前节点所关联的兄弟节点 return// 当前节点所关联的父节点 } 这样设计的好处就是在数据层已经在不同节点的关系给描述了出来，即便某一次任务被终止，当下次恢复任务时，这种结构也利于react恢复任务现场，知道自己接下来应该处理哪些节点。\n支持增量渲染，fiber将react中的渲染任务拆分到每一帧。 支持暂停，终止以及恢复之前的渲染任务。（没渲染时间了就将控制权让回浏览器） 通过fiber赋予了不同任务的优先级。（让优先级高的运行，比如事件交互响应，页面渲染等，像网络请求之类的往后排） 支持并发处理（面对可变的一堆任务，react始终处理最高优先级，灵活调整处理顺序，保证重要的任务都会在允许的最快时间内响应）\n首先需要处理输入事件，能够让用户得到最早的反馈 接下来是处理定时器，需要检查定时器是否到时间，并执行对应的回调 接下来处理 Begin Frame（开始帧），即每一帧的事件，包括 window.resize、scroll、media query change 等 接下来执行请求动画帧 requestAnimationFrame（rAF），即在每次绘制之前，会执行 rAF 回调 紧接着进行 Layout 操作，包括计算布局和更新布局，即这个元素的样式是怎样的，它应该在页面如何展示 接着进行 Paint 操作，得到树中每个节点的尺寸与位置等信息，浏览器针对每个元素进行内容填充 到这时以上的六个阶段都已经完成了，接下来处于空闲阶段（Idle Peroid），可以在这时执行 requestIdleCallback 里注册的任务 3 requestIdleCallback window.requestIdleCallback() 方法插入一个函数，这个函数将在浏览器空闲时期被调用。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。\nrequestIdleCallback 也能接受一个 callback，而这个callback 又能接收一个由浏览器告知你执行剩余时间的参数IdleDeadline\nconst process = (deadline) =\u003e { // 通过deadline.timeRemaining可获取剩余时间 console.log('deadline', deadline.timeRemaining()); } window.requestIdleCallback(process); 但需要注意的是，react在最终实现上并未直接采用 requestIdleCallback，一方面是requestIdleCallback目前还是实验中的api（https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback），兼容性不是非常好，性能较低。于是react通过MessageChannel + requestAnimationFrame 自己模拟实现了requestIdleCallback。\n(timeout )\n4 requestAnimationFrame（callback） window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行（60帧/秒）（更少的cpu，内存使用量）\ncallback 下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。 该回调函数会被传入DOMHighResTimeStamp参数，该参数与performance.now()的返回值相同， 它表示requestAnimationFrame() 开始去执行回调函数的时刻。\n当前帧结束时间： 我们知道requestAnimationFrame的回调被执行的时机是当前帧开始绘制之前。也就是说DOMHighResTimeStamp是当前帧开始时候的时间，如果按照每一帧执行的时间是16.66ms。那么我们就能算出当前帧结束的时间， frameDeadline = DOMHighResTimeStamp + 16.66。 当前帧剩余时间：当前帧剩余时间 = 当前帧结束时间(frameDeadline) - performance.now()。react中是用MessageChannel实现计算的。 区别：\nrequestAnimationFrame 的回调会在每一帧确定执行，属于高优先级任务 requestIdleCallback 的回调则不一定，有空闲时间才执行，属于低优先级任务。 5 MessageChannel MessageChannel允许我们在不同的浏览上下文，比如window.open()打开的窗口或者iframe等之间建立通信管道，并通过两端的端口（port1和port2）发送消息。MessageChannel以DOM Event的形式发送消息，所以它属于异步的宏任务。\nconst { port1, port2 } = new MessageChannel(); port1.onmessage = function (event) { console.log('收到来自port2的消息：', event.data); // 收到来自port2的消息： pong }; port2.onmessage = function (event) { console.log('收到来自port1的消息：', event.data); // 收到来自port1的消息： ping port2.postMessage('pong'); }; port1.postMessage('ping'); 应用场景\nEventEmitter 做事件的订阅发布，实现不同脚本之间的通信\n// a.js export default function a(port) { port.postMessage({ from: 'a', message: 'ping' }); } // b.js export default function b(port) { port.onmessage = (e) =\u003e { console.log(e.data); // {from: 'a', message: 'ping'} }; } // index.js import a from './a.js'; import b from './b.js'; const { port1, port2 } = new MessageChannel(); b(port2); a(port1); iframe window与单个iframe或者多个iframe之间的通信可以使用MessageChannel，通过只暴露有限的能力从而保证安全性。\nWeb Worker Web Worker 可以使脚本运行在新的线程中，它们独立于主线程，可以进行大量的计算活动，而不会影响主线程的 UI 渲染。当计算结束之后，它们可以把结果发送给主线程，从而形成了高效、良好的用户体验。\n// worker1.js self.onmessage = function (e) { console.log('receive a message from main window', e.data); // { command: 'connect' } if (e.data.command === 'connect') { self.postMessage({ message: 'connected' }); } }; // index.js const worker1 = new Worker('worker1.js'); worker1.postMessage({ command: 'connect' }); worker1.onmessage = function (e) { console.log('receive a message from worker1', e.data); // { message: 'connected' } }; react // 计算出当前帧 结束时间点 var deadlineTime // 保存任务 var callback // 建立通信 var channel = new MessageChannel() var port1 = channel.port1; var port2 = channel.port2; // 接收并执行宏任务 port2.onmessage = () =\u003e { // 判断当前帧是否还有空闲，即返回的是剩下的时间 const timeRemaining = () =\u003e deadlineTime - performance.now(); const _timeRemain = timeRemaining(); // 有空闲时间 且 有回调任务 if (_timeRemain \u003e 0 \u0026\u0026 callback) { const deadline = { timeRemaining, // 计算剩余时间 didTimeout: _timeRemain \u003c 0 // 当前帧是否完成 } // 执行回调 callback(deadline) } } window.requestIdleCallback = function (cb) { requestAnimationFrame(rafTime =\u003e { // 结束时间点 = 开始时间点 + 一帧用时16.667ms deadlineTime = rafTime + 16.667 // 保存任务 callback = cb // 发送个宏任务 port1.postMessage(null); }) } 6 调度器 暂停 JS 执行，将主线程还给浏览器，让浏览器有机会更新页面 在未来某个时刻继续调度任务，执行上次还没有完成的任务 React更新时和Scheduler的交互流程如下：\nReact 组件状态更新，向 Scheduler 中存入一个任务，该任务为 React 更新算法。 Scheduler 调度该任务，执行 React 更新算法。 React 在调和阶段（reconciliation）更新一个 Fiber 之后，会询问 Scheduler 是否需要暂停。如果不需要暂停，则重复步骤 3，继续更新下一个 Fiber。 如果 Scheduler 表示需要暂停，则 React 将返回一个函数，该函数用于告诉 Scheduler 任务还没有完成。Scheduler 将在未来某时刻调度该任务。 要满足这两点就需要调度一个宏任务，因为宏任务是在下次事件循环中执行，不会阻塞本次页面更新。而微任务是在本次页面更新前执行，与同步执行无异，不会让出主线程。\n理想情况下每一帧都是一次loop，但如果因为某些原因，如某微任务执行太久，时间超出当前帧(16.66ms)甚至超出多帧，那么本次循环将在该微任务执行完才结束，然后才进行渲染，也就是所说的掉帧。\n7 高频短期时间片 由于 rAF 仰仗显示器的刷新频率，太过依赖设备本身运作流程，存在不稳定性。为了在每一帧尽可能多的执行任务，React 团队采用了 5ms 间隔的宏任务消息事件来发起任务调度。\nScheduler 会将任务分为两种类型：taskQueue 和 timerQueue， taskQueue 队列中存放的是需要立即执行的任务（已就绪任务）； timerQueue 队列中存放的是可以延期执行的任务（未就绪任务）。 所以分别提供了两种调度任务方式：requestHostCallback 和 requestHostTimeout。\nshouldYieldToHost 会被用在外部 workLoop 循环执行任务时，确定是否需要中断执行，让出主线程。 workLoop 循环\n判断当前任务是否过期 如果过期了，则一定要在当前宏任务事件中执行完成 如果还没过期，则需要判断当前宏任务事件执行时间是否超过 5 毫秒，如果超过，则退出循环，剩余任务在下一个宏任务事件中处理 if (typeof window === 'undefined' || typeof MessageChannel !== 'function') { // 非浏览器环境，或不支持 MessageChannel，会使用 setTimeout 宏任务来实现 } else { // 保存 api 引用，防止 polyfill 覆盖它们 const setTimeout = window.setTimeout; const clearTimeout = window.clearTimeout; getCurrentTime = () =\u003e performance.now(); // 页面加载后开始计算 let isMessageLoopRunning = false; // 标记 MessageChannel 正在运行 let scheduledHostCallback = null; // 要执行的处理函数 let taskTimeoutID = -1; // 用作终止 setTimeout 延迟任务 // 定义每一帧工作时间，默认时间为 5ms，React 会根据浏览器主机环境进行重新计算。 let yieldInterval = 5; let deadline = 0; // 过期时间，让出主线程 // 让出主线程 shouldYieldToHost = function () { return getCurrentTime() \u003e= deadline; }; // 默认空闲执行时间是5ms，用户可通过该方法来根据不同用户主机的设备刷新率（FPS）来计算预留时间 forceFrameRate = function (fps) { if (fps \u003c 0 || fps \u003e 125) { return; } if (fps \u003e 0) { yieldInterval = Math.floor(1000 / fps); } else { yieldInterval = 5; } }; // 开启高频短间隔 5ms 执行工作 const performWorkUntilDeadline = () =\u003e { ... }; // 定义宏任务，建立通信 const channel = new MessageChannel(); const port = channel.port2; // 用于发布任务 channel.port1.onmessage = performWorkUntilDeadline; // 处理任务 requestHostCallback = function (callback) { scheduledHostCallback = callback; // 保存任务 if (!isMessageLoopRunning) { isMessageLoopRunning = true; port.postMessage(null); // 发起宏任务 } }; cancelHostCallback = function () { scheduledHostCallback = null; }; requestHostTimeout = function (callback, ms) { taskTimeoutID = setTimeout(() =\u003e { callback(getCurrentTime()); }, ms); }; cancelHostTimeout = function () { clearTimeout(taskTimeoutID); taskTimeoutID = -1; }; } const performWorkUntilDeadline = () =\u003e { if (scheduledHostCallback !== null) { const currentTime = getCurrentTime(); // 拿到当前时间 // 根据 yieldInterval（5ms）计算剩余时间（任务执行截止时间）。这种方式意味着 port.postMessage 开始后总有剩余时间 deadline = currentTime + yieldInterval; // 标识还有时间，类似 requestIdleCallback deadline.didTimeout const hasTimeRemaining = true; try { const hasMoreWork = scheduledHostCallback( hasTimeRemaining, currentTime, ); // 执行完成，没有新任务，初始化工作环境 if (!hasMoreWork) { isMessageLoopRunning = false; scheduledHostCallback = null; } else { // 如果任务截止时间过期（根据 shouldYieldToHost()），还有需要处理的工作，再发起一个异步宏任务 port.postMessage(null); } } catch (error) { port.postMessage(null); throw error; } } else { isMessageLoopRunning = false; } }; 宏任务 settimeout() 原因是setTimeout在递归调用下，塞入队列的最低延时会变为4ms，一帧一共就16ms， 高频短期时间片默认也就5ms，浪费的这3~4ms是不可容忍的。\nrequestAnimationFrame 从流程上看，RAF的执行时机是在渲染前，但其实浏览器并没有规定应该何时渲染页面，因此RAF是不稳定的。\n8 reconcile 使用tag（标签名）和 key识别节点，区分出前后的节点是否变化，以达到尽量复用无变化的节点\n更新删除节点 react 的 diff 算法分为两个阶段： 第一个阶段一一对比，如果可以复用就下一个，不可以复用就结束。 第二个阶段把剩下的老 fiber 放到 map 里，遍历剩余的 vdom，一一查找 map 中是否有可复用的节点。 最后把剩下的老 fiber 删掉，剩下的新 vdom 新增。 这样就完成了更新时的 reconcile 过程。\nreact vue 区别 1 react : 用户感知 2 vue : 缩短运算时间\n\u003cdiv id=\"virtual-dom\"\u003e \u003cp\u003eVirtual DOM\u003c/p\u003e \u003cul id=\"list\"\u003e \u003cli class=\"item\"\u003eItem 1\u003c/li\u003e \u003cli class=\"item\"\u003eItem 2\u003c/li\u003e \u003cli class=\"item\"\u003eItem 3\u003c/li\u003e \u003c/ul\u003e \u003cdiv\u003eHello World\u003c/div\u003e \u003c/div\u003e var el = require(\"./element.js\"); var ul = el('div',{id:'virtual-dom'}, [ el('p',{},['Virtual DOM']), el('ul', { id: 'list' }, [\tel('li', { class: 'item' }, ['Item 1']), el('li', { class: 'item' }, ['Item 2']), el('li', { class: 'item' }, ['Item 3'])]), el('div',{},['Hello World']) ]) vue3 流程 1 预处理 头头尾尾 2 新增节点 oldEnd \u003c j 成立，说明在预处理时，所有旧子节点都处理完毕了 newEnd \u003e= j 成立，说明预处理后，新的一组子节点中，存在未被处理的节点，这些节点就是新增的节点 3 删除节点 oldend \u003e= j 存在未被处理的节点 newend \u003c j 新节点 已经都处理过了 4 重新编号之前，最长递增子序列对应的是 新节点在旧节点列表中的为止 而编号之后，最长递增子序列对应的是 具体的节点\n最长增长子序列 动态 贪心+二分 得到正确顺序的核心是记录前驱节点 React fiber 1 流程 JS 是单线程的，浏览器是多线程的 对于多线程的浏览器而言，它除了要处理 JS这个线程，它还要处理定时器，网络请求，UI渲染…这些线程。 问题：浏览器中JS线程与UI线程互斥，假设这段代码运行的时间很久，那么浏览器就必须一直等待，严重情况下浏览器还可能失去响应 Fiber vs Stack Demo\n卡顿，掉帧 人眼：24帧/秒 递归 dom 树\n2 fiber 从运行机制上来解释，fiber是一种流程让出机制，它能让react中的同步渲染进行中断，并将渲染的控制权让回浏览器，从而达到不阻塞浏览器渲染的目的。 从数据角度来解释，fiber能细化成一种数据结构，或者一个执行单元。 传统： fiber： 数据结构：\nconst fiber = { stateNode,// dom节点实例 child,// 当前节点所关联的子节点 sibling,// 当前节点所关联的兄弟节点 return// 当前节点所关联的父节点 } 这样设计的好处就是在数据层已经在不同节点的关系给描述了出来，即便某一次任务被终止，当下次恢复任务时，这种结构也利于react恢复任务现场，知道自己接下来应该处理哪些节点。\n支持增量渲染，fiber将react中的渲染任务拆分到每一帧。 支持暂停，终止以及恢复之前的渲染任务。（没渲染时间了就将控制权让回浏览器） 通过fiber赋予了不同任务的优先级。（让优先级高的运行，比如事件交互响应，页面渲染等，像网络请求之类的往后排） 支持并发处理（面对可变的一堆任务，react始终处理最高优先级，灵活调整处理顺序，保证重要的任务都会在允许的最快时间内响应）\n首先需要处理输入事件，能够让用户得到最早的反馈 接下来是处理定时器，需要检查定时器是否到时间，并执行对应的回调 接下来处理 Begin Frame（开始帧），即每一帧的事件，包括 window.resize、scroll、media query change 等 接下来执行请求动画帧 requestAnimationFrame（rAF），即在每次绘制之前，会执行 rAF 回调 紧接着进行 Layout 操作，包括计算布局和更新布局，即这个元素的样式是怎样的，它应该在页面如何展示 接着进行 Paint 操作，得到树中每个节点的尺寸与位置等信息，浏览器针对每个元素进行内容填充 到这时以上的六个阶段都已经完成了，接下来处于空闲阶段（Idle Peroid），可以在这时执行 requestIdleCallback 里注册的任务 3 requestIdleCallback window.requestIdleCallback() 方法插入一个函数，这个函数将在浏览器空闲时期被调用。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。\nrequestIdleCallback 也能接受一个 callback，而这个callback 又能接收一个由浏览器告知你执行剩余时间的参数IdleDeadline\nconst process = (deadline) =\u003e { // 通过deadline.timeRemaining可获取剩余时间 console.log('deadline', deadline.timeRemaining()); } window.requestIdleCallback(process); 但需要注意的是，react在最终实现上并未直接采用 requestIdleCallback，一方面是requestIdleCallback目前还是实验中的api（https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback），兼容性不是非常好，性能较低。于是react通过MessageChannel + requestAnimationFrame 自己模拟实现了requestIdleCallback。\n(timeout )\n4 requestAnimationFrame（callback） window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行（60帧/秒）（更少的cpu，内存使用量）\ncallback 下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。 该回调函数会被传入DOMHighResTimeStamp参数，该参数与performance.now()的返回值相同， 它表示requestAnimationFrame() 开始去执行回调函数的时刻。\n当前帧结束时间： 我们知道requestAnimationFrame的回调被执行的时机是当前帧开始绘制之前。也就是说DOMHighResTimeStamp是当前帧开始时候的时间，如果按照每一帧执行的时间是16.66ms。那么我们就能算出当前帧结束的时间， frameDeadline = DOMHighResTimeStamp + 16.66。 当前帧剩余时间：当前帧剩余时间 = 当前帧结束时间(frameDeadline) - performance.now()。react中是用MessageChannel实现计算的。 区别：\nrequestAnimationFrame 的回调会在每一帧确定执行，属于高优先级任务 requestIdleCallback 的回调则不一定，有空闲时间才执行，属于低优先级任务。 5 MessageChannel MessageChannel允许我们在不同的浏览上下文，比如window.open()打开的窗口或者iframe等之间建立通信管道，并通过两端的端口（port1和port2）发送消息。MessageChannel以DOM Event的形式发送消息，所以它属于异步的宏任务。\nconst { port1, port2 } = new MessageChannel(); port1.onmessage = function (event) { console.log('收到来自port2的消息：', event.data); // 收到来自port2的消息： pong }; port2.onmessage = function (event) { console.log('收到来自port1的消息：', event.data); // 收到来自port1的消息： ping port2.postMessage('pong'); }; port1.postMessage('ping'); 应用场景\nEventEmitter 做事件的订阅发布，实现不同脚本之间的通信\n// a.js export default function a(port) { port.postMessage({ from: 'a', message: 'ping' }); } // b.js export default function b(port) { port.onmessage = (e) =\u003e { console.log(e.data); // {from: 'a', message: 'ping'} }; } // index.js import a from './a.js'; import b from './b.js'; const { port1, port2 } = new MessageChannel(); b(port2); a(port1); iframe window与单个iframe或者多个iframe之间的通信可以使用MessageChannel，通过只暴露有限的能力从而保证安全性。\nWeb Worker Web Worker 可以使脚本运行在新的线程中，它们独立于主线程，可以进行大量的计算活动，而不会影响主线程的 UI 渲染。当计算结束之后，它们可以把结果发送给主线程，从而形成了高效、良好的用户体验。\n// worker1.js self.onmessage = function (e) { console.log('receive a message from main window', e.data); // { command: 'connect' } if (e.data.command === 'connect') { self.postMessage({ message: 'connected' }); } }; // index.js const worker1 = new Worker('worker1.js'); worker1.postMessage({ command: 'connect' }); worker1.onmessage = function (e) { console.log('receive a message from worker1', e.data); // { message: 'connected' } }; react // 计算出当前帧 结束时间点 var deadlineTime // 保存任务 var callback // 建立通信 var channel = new MessageChannel() var port1 = channel.port1; var port2 = channel.port2; // 接收并执行宏任务 port2.onmessage = () =\u003e { // 判断当前帧是否还有空闲，即返回的是剩下的时间 const timeRemaining = () =\u003e deadlineTime - performance.now(); const _timeRemain = timeRemaining(); // 有空闲时间 且 有回调任务 if (_timeRemain \u003e 0 \u0026\u0026 callback) { const deadline = { timeRemaining, // 计算剩余时间 didTimeout: _timeRemain \u003c 0 // 当前帧是否完成 } // 执行回调 callback(deadline) } } window.requestIdleCallback = function (cb) { requestAnimationFrame(rafTime =\u003e { // 结束时间点 = 开始时间点 + 一帧用时16.667ms deadlineTime = rafTime + 16.667 // 保存任务 callback = cb // 发送个宏任务 port1.postMessage(null); }) } 6 调度器 暂停 JS 执行，将主线程还给浏览器，让浏览器有机会更新页面 在未来某个时刻继续调度任务，执行上次还没有完成的任务 React更新时和Scheduler的交互流程如下：\nReact 组件状态更新，向 Scheduler 中存入一个任务，该任务为 React 更新算法。 Scheduler 调度该任务，执行 React 更新算法。 React 在调和阶段（reconciliation）更新一个 Fiber 之后，会询问 Scheduler 是否需要暂停。如果不需要暂停，则重复步骤 3，继续更新下一个 Fiber。 如果 Scheduler 表示需要暂停，则 React 将返回一个函数，该函数用于告诉 Scheduler 任务还没有完成。Scheduler 将在未来某时刻调度该任务。 要满足这两点就需要调度一个宏任务，因为宏任务是在下次事件循环中执行，不会阻塞本次页面更新。而微任务是在本次页面更新前执行，与同步执行无异，不会让出主线程。\n理想情况下每一帧都是一次loop，但如果因为某些原因，如某微任务执行太久，时间超出当前帧(16.66ms)甚至超出多帧，那么本次循环将在该微任务执行完才结束，然后才进行渲染，也就是所说的掉帧。\n7 高频短期时间片 由于 rAF 仰仗显示器的刷新频率，太过依赖设备本身运作流程，存在不稳定性。为了在每一帧尽可能多的执行任务，React 团队采用了 5ms 间隔的宏任务消息事件来发起任务调度。\nScheduler 会将任务分为两种类型：taskQueue 和 timerQueue， taskQueue 队列中存放的是需要立即执行的任务（已就绪任务）； timerQueue 队列中存放的是可以延期执行的任务（未就绪任务）。 所以分别提供了两种调度任务方式：requestHostCallback 和 requestHostTimeout。\nshouldYieldToHost 会被用在外部 workLoop 循环执行任务时，确定是否需要中断执行，让出主线程。 workLoop 循环\n判断当前任务是否过期 如果过期了，则一定要在当前宏任务事件中执行完成 如果还没过期，则需要判断当前宏任务事件执行时间是否超过 5 毫秒，如果超过，则退出循环，剩余任务在下一个宏任务事件中处理 if (typeof window === 'undefined' || typeof MessageChannel !== 'function') { // 非浏览器环境，或不支持 MessageChannel，会使用 setTimeout 宏任务来实现 } else { // 保存 api 引用，防止 polyfill 覆盖它们 const setTimeout = window.setTimeout; const clearTimeout = window.clearTimeout; getCurrentTime = () =\u003e performance.now(); // 页面加载后开始计算 let isMessageLoopRunning = false; // 标记 MessageChannel 正在运行 let scheduledHostCallback = null; // 要执行的处理函数 let taskTimeoutID = -1; // 用作终止 setTimeout 延迟任务 // 定义每一帧工作时间，默认时间为 5ms，React 会根据浏览器主机环境进行重新计算。 let yieldInterval = 5; let deadline = 0; // 过期时间，让出主线程 // 让出主线程 shouldYieldToHost = function () { return getCurrentTime() \u003e= deadline; }; // 默认空闲执行时间是5ms，用户可通过该方法来根据不同用户主机的设备刷新率（FPS）来计算预留时间 forceFrameRate = function (fps) { if (fps \u003c 0 || fps \u003e 125) { return; } if (fps \u003e 0) { yieldInterval = Math.floor(1000 / fps); } else { yieldInterval = 5; } }; // 开启高频短间隔 5ms 执行工作 const performWorkUntilDeadline = () =\u003e { ... }; // 定义宏任务，建立通信 const channel = new MessageChannel(); const port = channel.port2; // 用于发布任务 channel.port1.onmessage = performWorkUntilDeadline; // 处理任务 requestHostCallback = function (callback) { scheduledHostCallback = callback; // 保存任务 if (!isMessageLoopRunning) { isMessageLoopRunning = true; port.postMessage(null); // 发起宏任务 } }; cancelHostCallback = function () { scheduledHostCallback = null; }; requestHostTimeout = function (callback, ms) { taskTimeoutID = setTimeout(() =\u003e { callback(getCurrentTime()); }, ms); }; cancelHostTimeout = function () { clearTimeout(taskTimeoutID); taskTimeoutID = -1; }; } const performWorkUntilDeadline = () =\u003e { if (scheduledHostCallback !== null) { const currentTime = getCurrentTime(); // 拿到当前时间 // 根据 yieldInterval（5ms）计算剩余时间（任务执行截止时间）。这种方式意味着 port.postMessage 开始后总有剩余时间 deadline = currentTime + yieldInterval; // 标识还有时间，类似 requestIdleCallback deadline.didTimeout const hasTimeRemaining = true; try { const hasMoreWork = scheduledHostCallback( hasTimeRemaining, currentTime, ); // 执行完成，没有新任务，初始化工作环境 if (!hasMoreWork) { isMessageLoopRunning = false; scheduledHostCallback = null; } else { // 如果任务截止时间过期（根据 shouldYieldToHost()），还有需要处理的工作，再发起一个异步宏任务 port.postMessage(null); } } catch (error) { port.postMessage(null); throw error; } } else { isMessageLoopRunning = false; } }; 宏任务 settimeout() 原因是setTimeout在递归调用下，塞入队列的最低延时会变为4ms，一帧一共就16ms， 高频短期时间片默认也就5ms，浪费的这3~4ms是不可容忍的。\nrequestAnimationFrame 从流程上看，RAF的执行时机是在渲染前，但其实浏览器并没有规定应该何时渲染页面，因此RAF是不稳定的。\n8 reconcile 使用tag（标签名）和 key识别节点，区分出前后的节点是否变化，以达到尽量复用无变化的节点\n更新删除节点 react 的 diff 算法分为两个阶段： 第一个阶段一一对比，如果可以复用就下一个，不可以复用就结束。 第二个阶段把剩下的老 fiber 放到 map 里，遍历剩余的 vdom，一一查找 map 中是否有可复用的节点。 最后把剩下的老 fiber 删掉，剩下的新 vdom 新增。 这样就完成了更新时的 reconcile 过程。\nreact vue 区别 1 react : 用户感知 2 vue : 缩短运算时间\n\u003cdiv id=\"virtual-dom\"\u003e \u003cp\u003eVirtual DOM\u003c/p\u003e \u003cul id=\"list\"\u003e \u003cli class=\"item\"\u003eItem 1\u003c/li\u003e \u003cli class=\"item\"\u003eItem 2\u003c/li\u003e \u003cli class=\"item\"\u003eItem 3\u003c/li\u003e \u003c/ul\u003e \u003cdiv\u003eHello World\u003c/div\u003e \u003c/div\u003e var el = require(\"./element.js\"); var ul = el('div',{id:'virtual-dom'}, [ el('p',{},['Virtual DOM']), el('ul', { id: 'list' }, [\tel('li', { class: 'item' }, ['Item 1']), el('li', { class: 'item' }, ['Item 2']), el('li', { class: 'item' }, ['Item 3'])]), el('div',{},['Hello World']) ]) vue3 流程 1 预处理 头头尾尾 2 新增节点 oldEnd \u003c j 成立，说明在预处理时，所有旧子节点都处理完毕了 newEnd \u003e= j 成立，说明预处理后，新的一组子节点中，存在未被处理的节点，这些节点就是新增的节点 3 删除节点 oldend \u003e= j 存在未被处理的节点 newend \u003c j 新节点 已经都处理过了 4 重新编号之前，最长递增子序列对应的是 新节点在旧节点列表中的为止 而编号之后，最长递增子序列对应的是 具体的节点\n最长增长子序列 动态 贪心+二分 得到正确顺序的核心是记录前驱节点 React fiber 1 流程 JS 是单线程的，浏览器是多线程的 对于多线程的浏览器而言，它除了要处理 JS这个线程，它还要处理定时器，网络请求，UI渲染…这些线程。 问题：浏览器中JS线程与UI线程互斥，假设这段代码运行的时间很久，那么浏览器就必须一直等待，严重情况下浏览器还可能失去响应 Fiber vs Stack Demo\n卡顿，掉帧 人眼：24帧/秒 递归 dom 树\n2 fiber 从运行机制上来解释，fiber是一种流程让出机制，它能让react中的同步渲染进行中断，并将渲染的控制权让回浏览器，从而达到不阻塞浏览器渲染的目的。 从数据角度来解释，fiber能细化成一种数据结构，或者一个执行单元。 传统： fiber： 数据结构：\nconst fiber = { stateNode,// dom节点实例 child,// 当前节点所关联的子节点 sibling,// 当前节点所关联的兄弟节点 return// 当前节点所关联的父节点 } 这样设计的好处就是在数据层已经在不同节点的关系给描述了出来，即便某一次任务被终止，当下次恢复任务时，这种结构也利于react恢复任务现场，知道自己接下来应该处理哪些节点。\n支持增量渲染，fiber将react中的渲染任务拆分到每一帧。 支持暂停，终止以及恢复之前的渲染任务。（没渲染时间了就将控制权让回浏览器） 通过fiber赋予了不同任务的优先级。（让优先级高的运行，比如事件交互响应，页面渲染等，像网络请求之类的往后排） 支持并发处理（面对可变的一堆任务，react始终处理最高优先级，灵活调整处理顺序，保证重要的任务都会在允许的最快时间内响应）\n首先需要处理输入事件，能够让用户得到最早的反馈 接下来是处理定时器，需要检查定时器是否到时间，并执行对应的回调 接下来处理 Begin Frame（开始帧），即每一帧的事件，包括 window.resize、scroll、media query change 等 接下来执行请求动画帧 requestAnimationFrame（rAF），即在每次绘制之前，会执行 rAF 回调 紧接着进行 Layout 操作，包括计算布局和更新布局，即这个元素的样式是怎样的，它应该在页面如何展示 接着进行 Paint 操作，得到树中每个节点的尺寸与位置等信息，浏览器针对每个元素进行内容填充 到这时以上的六个阶段都已经完成了，接下来处于空闲阶段（Idle Peroid），可以在这时执行 requestIdleCallback 里注册的任务 3 requestIdleCallback window.requestIdleCallback() 方法插入一个函数，这个函数将在浏览器空闲时期被调用。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。\nrequestIdleCallback 也能接受一个 callback，而这个callback 又能接收一个由浏览器告知你执行剩余时间的参数IdleDeadline\nconst process = (deadline) =\u003e { // 通过deadline.timeRemaining可获取剩余时间 console.log('deadline', deadline.timeRemaining()); } window.requestIdleCallback(process); 但需要注意的是，react在最终实现上并未直接采用 requestIdleCallback，一方面是requestIdleCallback目前还是实验中的api（https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback），兼容性不是非常好，性能较低。于是react通过MessageChannel + requestAnimationFrame 自己模拟实现了requestIdleCallback。\n(timeout )\n4 requestAnimationFrame（callback） window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行（60帧/秒）（更少的cpu，内存使用量）\ncallback 下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。 该回调函数会被传入DOMHighResTimeStamp参数，该参数与performance.now()的返回值相同， 它表示requestAnimationFrame() 开始去执行回调函数的时刻。\n当前帧结束时间： 我们知道requestAnimationFrame的回调被执行的时机是当前帧开始绘制之前。也就是说DOMHighResTimeStamp是当前帧开始时候的时间，如果按照每一帧执行的时间是16.66ms。那么我们就能算出当前帧结束的时间， frameDeadline = DOMHighResTimeStamp + 16.66。 当前帧剩余时间：当前帧剩余时间 = 当前帧结束时间(frameDeadline) - performance.now()。react中是用MessageChannel实现计算的。 区别：\nrequestAnimationFrame 的回调会在每一帧确定执行，属于高优先级任务 requestIdleCallback 的回调则不一定，有空闲时间才执行，属于低优先级任务。 5 MessageChannel MessageChannel允许我们在不同的浏览上下文，比如window.open()打开的窗口或者iframe等之间建立通信管道，并通过两端的端口（port1和port2）发送消息。MessageChannel以DOM Event的形式发送消息，所以它属于异步的宏任务。\nconst { port1, port2 } = new MessageChannel(); port1.onmessage = function (event) { console.log('收到来自port2的消息：', event.data); // 收到来自port2的消息： pong }; port2.onmessage = function (event) { console.log('收到来自port1的消息：', event.data); // 收到来自port1的消息： ping port2.postMessage('pong'); }; port1.postMessage('ping'); 应用场景\nEventEmitter 做事件的订阅发布，实现不同脚本之间的通信\n// a.js export default function a(port) { port.postMessage({ from: 'a', message: 'ping' }); } // b.js export default function b(port) { port.onmessage = (e) =\u003e { console.log(e.data); // {from: 'a', message: 'ping'} }; } // index.js import a from './a.js'; import b from './b.js'; const { port1, port2 } = new MessageChannel(); b(port2); a(port1); iframe window与单个iframe或者多个iframe之间的通信可以使用MessageChannel，通过只暴露有限的能力从而保证安全性。\nWeb Worker Web Worker 可以使脚本运行在新的线程中，它们独立于主线程，可以进行大量的计算活动，而不会影响主线程的 UI 渲染。当计算结束之后，它们可以把结果发送给主线程，从而形成了高效、良好的用户体验。\n// worker1.js self.onmessage = function (e) { console.log('receive a message from main window', e.data); // { command: 'connect' } if (e.data.command === 'connect') { self.postMessage({ message: 'connected' }); } }; // index.js const worker1 = new Worker('worker1.js'); worker1.postMessage({ command: 'connect' }); worker1.onmessage = function (e) { console.log('receive a message from worker1', e.data); // { message: 'connected' } }; react // 计算出当前帧 结束时间点 var deadlineTime // 保存任务 var callback // 建立通信 var channel = new MessageChannel() var port1 = channel.port1; var port2 = channel.port2; // 接收并执行宏任务 port2.onmessage = () =\u003e { // 判断当前帧是否还有空闲，即返回的是剩下的时间 const timeRemaining = () =\u003e deadlineTime - performance.now(); const _timeRemain = timeRemaining(); // 有空闲时间 且 有回调任务 if (_timeRemain \u003e 0 \u0026\u0026 callback) { const deadline = { timeRemaining, // 计算剩余时间 didTimeout: _timeRemain \u003c 0 // 当前帧是否完成 } // 执行回调 callback(deadline) } } window.requestIdleCallback = function (cb) { requestAnimationFrame(rafTime =\u003e { // 结束时间点 = 开始时间点 + 一帧用时16.667ms deadlineTime = rafTime + 16.667 // 保存任务 callback = cb // 发送个宏任务 port1.postMessage(null); }) } 6 调度器 暂停 JS 执行，将主线程还给浏览器，让浏览器有机会更新页面 在未来某个时刻继续调度任务，执行上次还没有完成的任务 React更新时和Scheduler的交互流程如下：\nReact 组件状态更新，向 Scheduler 中存入一个任务，该任务为 React 更新算法。 Scheduler 调度该任务，执行 React 更新算法。 React 在调和阶段（reconciliation）更新一个 Fiber 之后，会询问 Scheduler 是否需要暂停。如果不需要暂停，则重复步骤 3，继续更新下一个 Fiber。 如果 Scheduler 表示需要暂停，则 React 将返回一个函数，该函数用于告诉 Scheduler 任务还没有完成。Scheduler 将在未来某时刻调度该任务。 要满足这两点就需要调度一个宏任务，因为宏任务是在下次事件循环中执行，不会阻塞本次页面更新。而微任务是在本次页面更新前执行，与同步执行无异，不会让出主线程。\n理想情况下每一帧都是一次loop，但如果因为某些原因，如某微任务执行太久，时间超出当前帧(16.66ms)甚至超出多帧，那么本次循环将在该微任务执行完才结束，然后才进行渲染，也就是所说的掉帧。\n7 高频短期时间片 由于 rAF 仰仗显示器的刷新频率，太过依赖设备本身运作流程，存在不稳定性。为了在每一帧尽可能多的执行任务，React 团队采用了 5ms 间隔的宏任务消息事件来发起任务调度。\nScheduler 会将任务分为两种类型：taskQueue 和 timerQueue， taskQueue 队列中存放的是需要立即执行的任务（已就绪任务）； timerQueue 队列中存放的是可以延期执行的任务（未就绪任务）。 所以分别提供了两种调度任务方式：requestHostCallback 和 requestHostTimeout。\nshouldYieldToHost 会被用在外部 workLoop 循环执行任务时，确定是否需要中断执行，让出主线程。 workLoop 循环\n判断当前任务是否过期 如果过期了，则一定要在当前宏任务事件中执行完成 如果还没过期，则需要判断当前宏任务事件执行时间是否超过 5 毫秒，如果超过，则退出循环，剩余任务在下一个宏任务事件中处理 if (typeof window === 'undefined' || typeof MessageChannel !== 'function') { // 非浏览器环境，或不支持 MessageChannel，会使用 setTimeout 宏任务来实现 } else { // 保存 api 引用，防止 polyfill 覆盖它们 const setTimeout = window.setTimeout; const clearTimeout = window.clearTimeout; getCurrentTime = () =\u003e performance.now(); // 页面加载后开始计算 let isMessageLoopRunning = false; // 标记 MessageChannel 正在运行 let scheduledHostCallback = null; // 要执行的处理函数 let taskTimeoutID = -1; // 用作终止 setTimeout 延迟任务 // 定义每一帧工作时间，默认时间为 5ms，React 会根据浏览器主机环境进行重新计算。 let yieldInterval = 5; let deadline = 0; // 过期时间，让出主线程 // 让出主线程 shouldYieldToHost = function () { return getCurrentTime() \u003e= deadline; }; // 默认空闲执行时间是5ms，用户可通过该方法来根据不同用户主机的设备刷新率（FPS）来计算预留时间 forceFrameRate = function (fps) { if (fps \u003c 0 || fps \u003e 125) { return; } if (fps \u003e 0) { yieldInterval = Math.floor(1000 / fps); } else { yieldInterval = 5; } }; // 开启高频短间隔 5ms 执行工作 const performWorkUntilDeadline = () =\u003e { ... }; // 定义宏任务，建立通信 const channel = new MessageChannel(); const port = channel.port2; // 用于发布任务 channel.port1.onmessage = performWorkUntilDeadline; // 处理任务 requestHostCallback = function (callback) { scheduledHostCallback = callback; // 保存任务 if (!isMessageLoopRunning) { isMessageLoopRunning = true; port.postMessage(null); // 发起宏任务 } }; cancelHostCallback = function () { scheduledHostCallback = null; }; requestHostTimeout = function (callback, ms) { taskTimeoutID = setTimeout(() =\u003e { callback(getCurrentTime()); }, ms); }; cancelHostTimeout = function () { clearTimeout(taskTimeoutID); taskTimeoutID = -1; }; } const performWorkUntilDeadline = () =\u003e { if (scheduledHostCallback !== null) { const currentTime = getCurrentTime(); // 拿到当前时间 // 根据 yieldInterval（5ms）计算剩余时间（任务执行截止时间）。这种方式意味着 port.postMessage 开始后总有剩余时间 deadline = currentTime + yieldInterval; // 标识还有时间，类似 requestIdleCallback deadline.didTimeout const hasTimeRemaining = true; try { const hasMoreWork = scheduledHostCallback( hasTimeRemaining, currentTime, ); // 执行完成，没有新任务，初始化工作环境 if (!hasMoreWork) { isMessageLoopRunning = false; scheduledHostCallback = null; } else { // 如果任务截止时间过期（根据 shouldYieldToHost()），还有需要处理的工作，再发起一个异步宏任务 port.postMessage(null); } } catch (error) { port.postMessage(null); throw error; } } else { isMessageLoopRunning = false; } }; 宏任务 settimeout() 原因是setTimeout在递归调用下，塞入队列的最低延时会变为4ms，一帧一共就16ms， 高频短期时间片默认也就5ms，浪费的这3~4ms是不可容忍的。\nrequestAnimationFrame 从流程上看，RAF的执行时机是在渲染前，但其实浏览器并没有规定应该何时渲染页面，因此RAF是不稳定的。\n8 reconcile 使用tag（标签名）和 key识别节点，区分出前后的节点是否变化，以达到尽量复用无变化的节点\n更新删除节点 react 的 diff 算法分为两个阶段： 第一个阶段一一对比，如果可以复用就下一个，不可以复用就结束。 第二个阶段把剩下的老 fiber 放到 map 里，遍历剩余的 vdom，一一查找 map 中是否有可复用的节点。 最后把剩下的老 fiber 删掉，剩下的新 vdom 新增。 这样就完成了更新时的 reconcile 过程。\nreact vue 区别 1 react : 用户感知 2 vue : 缩短运算时间\n\u003cdiv id=\"virtual-dom\"\u003e \u003cp\u003eVirtual DOM\u003c/p\u003e \u003cul id=\"list\"\u003e \u003cli class=\"item\"\u003eItem 1\u003c/li\u003e \u003cli class=\"item\"\u003eItem 2\u003c/li\u003e \u003cli class=\"item\"\u003eItem 3\u003c/li\u003e \u003c/ul\u003e \u003cdiv\u003eHello World\u003c/div\u003e \u003c/div\u003e var el = require(\"./element.js\"); var ul = el('div',{id:'virtual-dom'}, [ el('p',{},['Virtual DOM']), el('ul', { id: 'list' }, [\tel('li', { class: 'item' }, ['Item 1']), el('li', { class: 'item' }, ['Item 2']), el('li', { class: 'item' }, ['Item 3'])]), el('div',{},['Hello World']) ]) ","description":"vue3 和 react","tags":["vue","react","2023"],"title":"Vue3 React","uri":"/learn/vue3-react/"},{"content":"标题语法 # h1 ## h2 以此类推 到6 记得有空格 内容 ====== 表示h1 内容 ------ 表示h2 = / - 数量任意 ### 内容 {#id的名字} =》 \u003ch3 id=\"id的名字\"\u003e内容\u003c/h3\u003e 好像有的不支持 段落 空行空出来就分段了\n换行 结尾空格\n字体样式 **加粗内容** __加粗内容__ *斜体* _斜体_ ***粗体且斜体*** ___粗体且斜体___ 引用 \u003e引用内容 \u003e \u003e放在一段里面的引用内容 \u003e \u003e\u003e引用里面引用 列表 有序列表 1. 内容 2. 内容 数字+. 前面数字是啥无所谓，但一定要是1开始 无序列表 - 列表 * 列表 + 列表 + 缩进列表 三个符号都可以 代码 代码\n分隔线 内容 ************** -------------- ______________ * - _ 都可以作为分隔符 a标签语法 [a标签显示内容](链接地址 \"title\")e.g. [百度](https://www.baidu.com \"百度\")\n图片 ![图片alt](图片链接 \"图片title\")\n转义字符\\ 支持html标签插入 表格 | Title1\t| Title2 | | --------- |\t-------- | | content1 | content2 | # 不一定要对齐 | Syntax | Description | Test Text | | :--- | :----: | ---: | | 左对齐 | 剧中 | 右对齐 | 注脚 [^数字或者单词] 不能包含空格和制表符 Here's a simple footnote,[^1] and here's a longer one.[^bignote] [^1]: 注脚1 [^bignote]: 注脚2 删除线 删除线\n任务列表 - [x] x代表这一项完成了 - [ ] 空白代表还没有 自动网址链接 链接如果希望他仅仅做展示，不希望点击后跳走，可以使用反引号http://xxxxx.com\n","description":"markdown 语法学习","tags":["学习杂记","2024"],"title":"Markdown 语法学习","uri":"/learn/markdown/"},{"content":"electron 实际上是 chromium浏览器环境 + node环境 + 原生api的环境\n但三种环境在electron里不是哪里都可以用的，他把js分成了主进程环境和渲染进程环境 每个 Electron 应用都有一个单一的主进程，作为应用程序的入口点。 主进程在 Node.js 环境中运行，这意味着它具有 require 模块和使用所有 Node.js API 的能力,也拥有访问原生api的能力\n等到渲染进程就不再拥有这个能力了，所以有preload,他在页面加载之前执行，在这里仍然拥有访问node的能力。 语境隔离（Context Isolation）意味着预加载脚本与渲染器的主要运行环境是隔离开来的，以避免泄漏任何具特权的 API 到您的网页内容代码中。就是说preload中挂在window上的内容在渲染进程里访问不到\n那如果要在渲染的页面里面拿到preload里定义的方法，这个时候就可以使用contextBridge 进程间通信 https://www.electronjs.org/zh/docs/latest/tutorial/ipc\n渲染进程发，主进程听（单向） preload 里 ipcRenderer.send html页面里面，调用window上的api里注册的方法，就是preload里面注册的方法名字 main.js 里 ipcMain.on监听\n渲染进程发，主进程听完返回，相互通信（双向） preload里 ipcRenderer.invoke() html页面里面，调用上面的方法，同样在window上 main.js里面ipcMain.handle()\n主进程发，渲染进程听 main.js里面 mainWindow.webContents.send mainWindow就是渲染进程实例 然后再preload里面进行 ipcRenderer.on听 最后再页面上 调用preload里面定义的方法，做逻辑处理\n如果这里想要通信回去，就在页面上调用的方法里面，再调用一个方法发送给主进程\n两个渲染器进程 之能拿主进程做中转\n","description":"Electron 主进程 渲染进程","tags":["electron","2024"],"title":"Electron 主进程 渲染进程","uri":"/learn/electron-communication/"},{"content":"前提 毕业以后我的工资全部都存在工商银行的卡里，一般默认存进去的钱自动存活期，但是今年五月发现并没有，所以萌生了理财的想法。\n余额宝里目前有一些钱，然后就是把上面工商的钱存了定期，但是利率1.7有点低。理财产品看不懂，想先找一本书来看看，听说小狗钱钱可以入门。\n读书笔记 72定律\n72 除以投资的年收益率的百分比，得出的数字就是这笔钱翻一倍所要的年数\n72公式也可以用来帮助我们计算通货膨胀。它可以告诉我们，在一定通货膨胀率下，我们的钱在多长时间后会贬值一半。\n比如按72除以3%的通货膨胀率计算，得到24，就是说24年以后，你的钱只值现在的一半。\n记录 书里还提到一个观点时金钱不能使人变得幸福，幸福的人得到金钱会变得更加幸福，但是悲惨的人不会因为得到金钱而变得幸福。感觉很有道理，幸福的能力是自己给的，金钱固然能提升人的生活质量但是幸福的能力还是要靠自己来创造。\n书中对基金的概念也有了一个比较清晰易懂的介绍，基金是经理人受限要求购买至少二十种股票，然后把风险平坦，保证最终受益。书中的观点是行业都会迎来低谷期，但只有低谷期不卖出，就不会亏损，然后总会迎来行业回暖。\n书中主角对自己的财产进行了比例划分来进行管理，她将50%作为会下单的鹅，可持续发展，钱生钱。40%作为梦想基金来实现目标，所以在最开始就设立了要实现的目标。10%作为消费。\n我以前总是会把前面这90%搞混在一起，看起来好像没什么区别，但是风险小了，收益也小了。很多时候目标是攒钱，但是10%的界限又会越过，所以一个清晰的比例也有助于我对自己的钱有一个比较清晰的掌控。 我和主角的比例可能不太一样，我目前对理财有了一个大概的基础认知，算是入门了，我还要再学习一下相关知识。\n","description":"小狗钱钱-理财入门第一本","tags":["book","2024"],"title":"小狗钱钱-入门第一本","uri":"/readothers/finance-first/"},{"content":"安装 https://gohugo.io/installation/windows/直接用 scoop 安装最方便 go 安装msi文件运行就可以了\n新建 hugo new site [网站名字]\n挑选一个主题 https://themes.gohugo.io/\ngit submodule add [主题的github地址]\n在 hugo.toml 里面定义主题 theme = '主题名字'\nhugo server 启动\nhugo server -D 预览\n新建文章 hugo new content posts/my-first-post.md\nhugo 打包文件 会放到 public 目录下面\ngithub page 创建一个仓库 命名 username.github.io 然后把远程仓库拉到本地 git clone 远程仓库 把上面 public 目录下的所有文件复制过来 提交 推送远程仓库 访问 username.github.io hugo.toml 文件 # 设置默认语言为简体中文 defaultContentLanguage = 'zh-cn' # 要注意配置文件的 url 要更改成github page的路径！！！ baseURL = 'https://yjmbc.github.io/' [Params] # 指示网站是否为自托管 selfHosted = true # 设置日期格式为\"2006-01-02\"，即年-月-日 dateFormat = \"2006-01-02\" # 是否显示文章的预估阅读时间 readingTime = true # 是否在文章末尾显示字数统计 wordCount = true # 是否使用highlight.js进行代码高亮 useHLJS = true # 是否在文章底部显示相关文章推荐 showRelatedPosts = true # 是否显示文章的最后修改时间 Lastmod = true # 分页设置，每页显示的文章数量 pagination = \"10\" # 是否在文章页面隐藏作者信息 hideAuthor = true # 网站描述，可自定义内容 description=\"Your can add your website description here.\" # 是否启用基于Lunr的客户端搜索功能 lunrSearch = true # 预览卡片中图片的位置，此处设为显示在底部 previewCardImagePlacement = \"bottom\" # 用来设置右上角的导航栏内容, url 对应 content 目录下的路径 [[menu.main]] name = \"首页\" url = \"/\" weight = 1 # weight 用来定义导航栏的展示顺序，数值越小越靠前 [[menu.main]] name = \"学习记录\" url = \"/learn/\" weight = 2 文章开头定义 使用主题： lightbi-hugo\n--- title: hugo 实践记录 date: 2024-06-14 tags: [\"hugo\"] image : \"/img/work/bird.jpg\" Description : \"hugo 构建个人博客页并部署到 github page 全过程简便记录...\" --- tags 标签可以定义文章属于哪个标签，然后在 tags页面下按照标签展示img 是缩略卡片展示的图片内容以及内容页的展示图片，路径为themes/主题名字/assets/img下的路径\n文章导入过程 由于习惯用语雀进行记录，所以文章可以使用语雀进行编写，导出成markdown文件再放进来 提交 blog 项目一个仓库A，打包之后放到 github page 上的文件一个仓库B\nA 本地修改完成之后，hugo打包生成静态资源 # Hugo生成的静态文件 public/ # Hugo缓存目录 resources/ cache/ $hugocfg/workDir/ # 编译相关的临时文件 dist/ out/ build/ # Go模块的缓存 go.sum pkg/mod/ #编辑器和IDE相关的忽略规则 .idea/ .vscode/ *.sublime-workspace *.swp *.swo # 个人身份认证或密钥文件（确保不在版本控制中泄露敏感信息） id_rsa id_rsa.pub known_hosts # 其他可能不需要的文件类型 .DS_Store Thumbs.db *.log *.bak *.tmp 提交A到代码仓库 删除 github page 关联仓库B下所有代码 B重新关联 远程仓库 复制A public 文件夹下的内容到该项目B下 提交B到代码仓库 hugo time=$(date \"+%Y-%m-%d %H:%M:%S\") echo $time git add . git commit -m \"feat: 自动提交hugo代码 $time\" git push cd ../yjmbc.github.io/ rm -rf ./* git init git remote add origin https://github.com/yjmbc/yjmbc.github.io.git cd ../my-blog/ cp -r ./public/* ../yjmbc.github.io/ cd ../yjmbc.github.io/ git checkout main git add . git commit -m \"feat: 自动提交hugo public代码 $time\" git push 运行 build.sh 文件\n新建一个文章 大部分文章我都不是直接通过 md 来写，而是先在语雀上写好，然后导出为 md 文档，同时保留语雀的换行但是这样导出的文章，有两个问题\n换行符是跟在文本后面，并没有生效，我需要手动对换行符进行处理。 图片是 cdn 上的资源，我希望图片放在项目的静态资源文件夹里 所以需要一个程序来帮我对内容进行处理。\nconst fs = require(\"fs\"); const path = require(\"path\"); const axios = require(\"axios\"); // 从命令行读取需要转换的 markdown 文件的地址 const markdownFilePath = process.argv[2]; // 从命令行读取转换之后的文件的路径 const outputFile = process.argv[3]; // 路径里获取没有文件后缀名的文件名 const fileName = process.argv[3].replace(/^(.*\\/)?([^/.]+)\\..+$/, '$2'); if (!markdownFilePath) { console.error(\"确认需要转换的 markdown 文件路径\"); process.exit(1); } fs.readFile(markdownFilePath, \"utf-8\", (err, data) =\u003e { if (err) { console.error(\"读错误\", err); return; } const fileContent = transform(data); fs.appendFile(outputFile, fileContent, \"utf-8\", (err) =\u003e { if (err) { console.error(\"写入错误\", err); return; } }); }); /** * * @param {string} data */ function transform(data) { // 转换换行符 let contentWithoutBr = data.replace(/\u003cbr \\/\u003e/g, \" \\n\"); const imageRegex = /\\!\\[[^\\]]+\\]\\((https?:\\/\\/[^\\s)]+)\\)/g; let match; let num = 0; // 获取全部的语雀 cdn 图片链接 while ((match = imageRegex.exec(data)) !== null) { downLoadImages(match[1],`${fileName}-${num}.png`); // 把链接替换成下载下来的图片的名字 contentWithoutBr = contentWithoutBr.replace(match[1], `/images/${fileName}-${num}.png`); num++; } return contentWithoutBr; } async function downLoadImages(imageUrl, fileName) { // 发请求获取文件并保存到静态目录文件夹的图片下 try { const response = await axios.get(imageUrl, { responseType: 'stream' }); const writer = fs.createWriteStream(`./static/images/${fileName}`); response.data.pipe(writer); writer.on('error', (err) =\u003e { console.log(err); fs.unlink(`./${fileName}.png`, () =\u003e {}) }) }catch (err) { console.log('请求图片错误', err); } } 执行上面的文件需要传递两个参数，需要转化的 markdown 文件的地址，和创建的文章所在的地址当然图方便也可以用脚本实现\nif [-z \"$1\"]; then echo \"请输入md文件地址\" exit fi if [-z \"$2\"]; then echo \"请输入输出文件的地址\" exit fi hugo new $2 node ./transform.js $1 $2 从语雀导出文档后只要执行\n.\\createBlog.sh C:\\Users\\Administrator\\Downloads\\vue3-react.md ./content/learn/vue3-react.md\n","description":"hugo 构建个人博客页并部署到 github page 全过程简便记录...","tags":["hugo","2024"],"title":"hugo 实践记录","uri":"/work/hugo-start/"}]
